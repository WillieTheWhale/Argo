<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Argo - Revolutionary AI Voice Assistant | Transform Your Digital Life</title>
    <meta name="description" content="Experience the future of AI voice technology. Argo negotiates bills, schedules meetings, and handles calls with your voice. Join 25,000+ early adopters.">
    <meta name="keywords" content="AI voice assistant, voice cloning, bill negotiation, AI agent, voice technology, personal assistant">
    
    <!-- Open Graph Meta -->
    <meta property="og:title" content="Argo - The AI That Speaks For You">
    <meta property="og:description" content="Revolutionary voice AI that negotiates, schedules, and handles calls on your behalf. Join the waitlist now.">
    <meta property="og:type" content="website">
    
    <!-- Preload Critical Resources -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" as="style">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --argo-blue: #0066CC;
            --argo-dark-blue: #003D7A;
            --argo-light-blue: #E6F2FF;
            --argo-gold: #FFB800;
            --argo-dark-gold: #CC9200;
            --argo-white: #FFFFFF;
            --argo-gray: #F5F5F5;
            --pixel-size: 3px;
            
            /* Time-based dynamic colors */
            --time-tint: rgba(0, 0, 0, 0);
            --time-accent: var(--argo-gold);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        body {
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(180deg, #F5F5F3 0%, #F8F8F6 100%);
            background-attachment: fixed;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB4PSI2IiB5PSI2IiB3aWR0aD0iMyIgaGVpZ2h0PSIzIiBmaWxsPSIjMDA2NkNDIi8+PHJlY3QgeD0iOSIgeT0iNiIgd2lkdGg9IjMiIGhlaWdodD0iMyIgZmlsbD0iIzAwNjZDQyIvPjxyZWN0IHg9IjYiIHk9IjkiIHdpZHRoPSIzIiBoZWlnaHQ9IjMiIGZpbGw9IiMwMDY2Q0MiLz48L3N2Zz4='), auto;
        }

        /* WebGL Canvas Background */
        #webglCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.8;
        }



        /* Scroll Progress Indicator */
        .scroll-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--argo-light-blue);
            z-index: 9999;
        }

        .scroll-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--argo-gold) 0%, var(--argo-blue) 100%);
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Scroll Level Indicator */
        .level-indicator {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .level-dot {
            width: 12px;
            height: 12px;
            border: 2px solid var(--argo-blue);
            background: var(--argo-white);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .level-dot.active {
            background: var(--argo-gold);
            transform: scale(1.3);
        }

        .level-dot:hover::after {
            content: attr(data-section);
            position: absolute;
            left: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--argo-dark-blue);
            color: var(--argo-white);
            padding: 4px 8px;
            font-size: 6px;
            white-space: nowrap;
            border-radius: 4px;
        }

        /* Animated Sections */
        .section {
            min-height: 100vh;
            padding: 80px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .section-content {
            max-width: 1200px;
            width: 100%;
            position: relative;
            z-index: 10;
        }

        /* Scroll-triggered Animations */
        .scroll-element {
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .scroll-element.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Pixelate Animation */
        @keyframes pixelate {
            0% { filter: blur(10px) brightness(0.5); }
            50% { filter: blur(5px) brightness(0.8); }
            100% { filter: blur(0) brightness(1); }
        }

        .pixelate-in {
            animation: pixelate 1s ease-out;
        }

        /* Glitch Text Effect */
        .glitch-text {
            position: relative;
            display: inline-block;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0.8;
        }

        .glitch-text::before {
            animation: glitch1 0.5s infinite;
            color: var(--argo-gold);
            z-index: -1;
        }

        .glitch-text::after {
            animation: glitch2 0.5s infinite;
            color: var(--argo-blue);
            z-index: -2;
        }

        @keyframes glitch1 {
            0%, 100% { clip-path: inset(0 0 0 0); }
            20% { clip-path: inset(20% 0 60% 0); }
            40% { clip-path: inset(50% 0 20% 0); }
            60% { clip-path: inset(10% 0 80% 0); }
            80% { clip-path: inset(80% 0 10% 0); }
        }

        @keyframes glitch2 {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        /* Hero Section Enhanced */
        .hero-section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .hero-title {
            font-size: clamp(32px, 8vw, 72px);
            color: var(--argo-blue);
            text-shadow: 
                4px 4px 0 var(--argo-gold),
                8px 8px 0 var(--argo-dark-blue),
                8px 8px 20px rgba(0, 102, 204, 0.3);
            margin-bottom: 30px;
            animation: heroFloat 4s ease-in-out infinite;
            text-align: center;
        }

        @keyframes heroFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Time-based Messages */
        .time-message {
            background: #F8F8F6;
            background-image: 
                /* Subtle paper texture */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='150'%3E%3Cfilter id='time-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.95' numOctaves='2'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23time-noise)' opacity='0.015'/%3E%3C/svg%3E");
            border: 3px solid var(--time-accent);
            border-radius: 12px;
            padding: 15px 20px;
            margin: 20px auto;
            max-width: 600px;
            position: relative;
            animation: messageSlide 0.8s ease-out;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateX(-50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .time-message::after {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-right: 10px solid var(--time-accent);
        }

        /* ============================================
           PICTOCHAT PAPER TEXTURE & NOTEBOOK LINES
           Phase 5.1 Enhancement - Authentic DS Visual Feel
           ============================================ */
        
        /* Base paper texture for all white backgrounds */
        .pictochat-paper-bg {
            background-color: #F8F8F6 !important;
            background-image: 
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200' viewBox='0 0 200 200'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.03'/%3E%3C/svg%3E");
        }
        
        /* Community Gallery */
        .gallery-section {
            background-color: #F9F8F6;
            background-image: 
                /* Visible paper texture using CSS patterns */
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 40px,
                    rgba(0, 0, 0, 0.01) 40px,
                    rgba(0, 0, 0, 0.01) 80px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 40px,
                    rgba(0, 0, 0, 0.01) 40px,
                    rgba(0, 0, 0, 0.01) 80px
                ),
                /* Base gradient */
                radial-gradient(ellipse at top center, #FFFEFA 0%, #F5F4F2 100%);
            padding: 60px 20px;
            position: relative;
        }
        
        /* Add subtle paper shadow to gallery */
        .gallery-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(0,0,0,0.05) 50%, transparent 100%);
        }

        .gallery-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .gallery-title {
            font-size: 24px;
            color: var(--argo-dark-blue);
            margin-bottom: 15px;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .doodle-card {
            background: #FCFCFA;
            background-image: 
                /* Subtle paper texture for cards */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='card-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23card-noise)' opacity='0.02'/%3E%3C/svg%3E");
            border: 3px solid var(--argo-blue);
            border-radius: 8px;
            padding: 10px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            animation: doodleFadeIn 0.5s ease-out;
            background-image: 
                /* Subtle paper texture for cards */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='card-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='1'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23card-noise)' opacity='0.01'/%3E%3C/svg%3E");
            border: 3px solid var(--argo-blue);
            border-radius: 8px;
            padding: 10px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
            animation: doodleFadeIn 0.5s ease-out;
        }

        @keyframes doodleFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .doodle-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 5px 0 var(--argo-dark-blue),
                0 10px 20px rgba(0, 102, 204, 0.2);
        }

        .doodle-card.featured {
            border-color: var(--argo-gold);
            box-shadow: 0 0 20px rgba(255, 184, 0, 0.3);
        }

        .doodle-image {
            width: 100%;
            aspect-ratio: 1;
            background: var(--argo-light-blue);
            border-radius: 4px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--argo-blue);
            image-rendering: pixelated;
        }

        .doodle-reactions {
            display: flex;
            justify-content: space-around;
            padding-top: 10px;
            border-top: 2px solid var(--argo-light-blue);
        }

        .reaction-btn {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease;
            position: relative;
        }

        .reaction-btn:hover {
            transform: scale(1.3);
        }

        .reaction-btn.active {
            animation: reactionPulse 0.5s ease;
        }

        @keyframes reactionPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.5); }
        }

        .reaction-count {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--argo-gold);
            color: var(--argo-white);
            font-size: 8px;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Press Start 2P', monospace;
        }

        /* Drawing Canvas Enhanced with Pictochat Styling */
        .canvas-container {
            background: #F9F8F6;
            background-image: 
                /* More visible paper texture using CSS pattern */
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.01) 10px,
                    rgba(0, 0, 0, 0.01) 20px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 10px,
                    rgba(0, 0, 0, 0.01) 10px,
                    rgba(0, 0, 0, 0.01) 20px
                ),
                /* Subtle gradient for depth */
                radial-gradient(ellipse at center, #FEFDFB 0%, #F5F4F2 100%);
            border: 4px solid var(--argo-dark-blue);
            border-radius: 0;
            padding: 20px;
            margin: 40px auto;
            max-width: 800px;
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.02),
                0 0 0 2px var(--argo-blue),
                0 8px 0 var(--argo-dark-blue);
            position: relative;
        }

        #enhancedCanvas {
            width: 100%;
            height: 400px;
            background-color: rgba(255, 255, 255, 0.8);
            background-image: 
                /* More visible notebook lines */
                repeating-linear-gradient(
                    180deg,
                    transparent,
                    transparent 23px,
                    #D8DEE9 23px,
                    #D8DEE9 24px
                );
            background-size: 100% 24px;
            border: 3px solid var(--argo-dark-blue);
            cursor: crosshair;
            touch-action: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.03);
        }
        
        /* Vertical margin line */
        #enhancedCanvas::after {
            content: '';
            position: absolute;
            left: 50px;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #FFB5B9;
            opacity: 0.3;
            pointer-events: none;
        }
        
        /* Pictochat Drawing Tools Panel */
        .drawing-tools-panel {
            display: flex;
            gap: 20px;
            padding: 15px;
            background: #FCFCFA;
            background-image: 
                /* Very subtle paper texture for tools panel */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='150'%3E%3Cfilter id='tools-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.8' numOctaves='1'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23tools-noise)' opacity='0.015'/%3E%3C/svg%3E");
            border: 3px solid var(--argo-blue);
            margin-top: 15px;
            font-family: 'Press Start 2P', monospace;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        
        .palette-label {
            font-size: 10px;
            color: var(--argo-dark-blue);
            margin-bottom: 8px;
            letter-spacing: 1px;
        }
        
        /* Enhanced Color Grid - Pictochat Style */
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }
        
        .color-swatch {
            width: 36px;
            height: 36px;
            border: 3px solid #999999;
            cursor: pointer;
            transition: all 0.15s ease;
            padding: 0;
            position: relative;
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.3);
        }
        
        .color-swatch:hover {
            border-color: var(--argo-blue);
            transform: scale(1.1);
            z-index: 10;
        }
        
        .color-swatch.active {
            border-color: var(--argo-gold);
            border-width: 4px;
            transform: scale(1.2);
            box-shadow: 
                0 0 0 2px var(--argo-white),
                0 0 0 4px var(--argo-gold),
                0 0 12px rgba(255, 184, 0, 0.5);
            z-index: 20;
        }
        
        .color-swatch.active::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* Brush Size Selector - DS Style */
        .brush-size-selector {
            display: flex;
            flex-direction: column;
        }
        
        .size-buttons {
            display: flex;
            gap: 8px;
        }
        
        .size-btn {
            width: 48px;
            height: 48px;
            background: var(--argo-gray);
            border: 3px solid var(--argo-blue);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .size-btn:hover {
            background: var(--argo-light-blue);
            transform: translateY(-3px);
            box-shadow: 0 3px 0 var(--argo-dark-blue);
        }
        
        .size-btn.active {
            background: var(--argo-blue);
            border-color: var(--argo-gold);
            transform: translateY(-1px);
            box-shadow: 0 1px 0 var(--argo-dark-blue);
        }
        
        .size-dot {
            background: #333333;
            border-radius: 0;
        }
        
        .size-btn.active .size-dot {
            background: var(--argo-white);
        }
        
        .size-dot.small {
            width: 4px;
            height: 4px;
        }
        
        .size-dot.medium {
            width: 8px;
            height: 8px;
        }
        
        .size-dot.large {
            width: 14px;
            height: 14px;
        }
        
        /* Tool Action Buttons - DS Style */
        .tool-actions {
            display: flex;
            gap: 8px;
        }
        
        .tool-btn {
            padding: 10px 15px;
            background: var(--argo-white);
            border: 3px solid var(--argo-blue);
            color: var(--argo-dark-blue);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .tool-btn:hover {
            background: var(--argo-blue);
            color: var(--argo-white);
            transform: translateY(-2px);
            box-shadow: 0 4px 0 var(--argo-dark-blue);
        }
        
        .tool-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 0 var(--argo-dark-blue);
        }
        
        .tool-btn.active-tool {
            background: var(--argo-gold);
            color: var(--argo-dark-blue);
            border-color: var(--argo-dark-blue);
        }
        
        /* ============================================
           PIXEL ICONS - REPLACEMENT FOR EMOJIS
           Added: Phase 3 Enhancement
           ============================================ */
        .pixel-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            vertical-align: middle;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            position: relative;
        }
        
        .pixel-icon.large {
            width: 24px;
            height: 24px;
        }
        
        .pixel-icon.small {
            width: 12px;
            height: 12px;
        }
        
        /* Animated pixel icons */
        @keyframes pixel-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        @keyframes pixel-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        
        .pixel-icon.heart:hover {
            animation: pixel-pulse 0.6s ease infinite;
        }
        
        .pixel-icon.fire {
            animation: pixel-bounce 1s ease infinite;
        }
        
        /* Save/Share Modal Styles */
        .share-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .share-modal.show {
            opacity: 1;
        }
        
        .modal-content {
            background: var(--argo-white);
            border: 4px solid var(--argo-blue);
            border-radius: 8px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            position: relative;
            box-shadow: 0 8px 0 var(--argo-dark-blue);
        }
        
        .modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--argo-dark-blue);
            font-family: 'Press Start 2P', monospace;
        }
        
        .modal-content h3 {
            font-size: 14px;
            color: var(--argo-dark-blue);
            margin-bottom: 15px;
            text-align: center;
        }
        
        .modal-subtitle {
            font-size: 10px;
            color: var(--argo-blue);
            text-align: center;
            margin-bottom: 20px;
        }
        
        .share-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .share-btn {
            background: var(--argo-white);
            border: 3px solid var(--argo-blue);
            border-radius: 4px;
            padding: 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .share-btn:hover {
            background: var(--argo-blue);
            color: var(--argo-white);
            transform: translateY(-2px);
        }
        
        .modal-note {
            font-size: 8px;
            color: var(--argo-dark-blue);
            text-align: center;
            margin-top: 15px;
            line-height: 1.5;
        }
        
        /* Save Notification */
        .save-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--argo-blue);
            color: var(--argo-white);
            padding: 12px 20px;
            border: 3px solid var(--argo-white);
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            z-index: 10002;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .save-notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* My Doodles Section */
        .my-doodles-section {
            background: var(--argo-gray);
            padding: 40px 20px;
            margin-top: 40px;
            border-top: 4px solid var(--argo-blue);
        }
        
        .my-doodles-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .my-doodles-title {
            font-size: 18px;
            color: var(--argo-dark-blue);
            margin-bottom: 10px;
        }
        
        #myDoodlesContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .my-doodle-item {
            background: var(--argo-white);
            border: 3px solid var(--argo-blue);
            border-radius: 6px;
            padding: 8px;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .my-doodle-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 0 var(--argo-dark-blue);
        }
        
        .my-doodle-item img {
            width: 100%;
            height: auto;
            display: block;
            image-rendering: pixelated;
        }
        
        .doodle-actions {
            display: flex;
            justify-content: space-around;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 2px solid var(--argo-light-blue);
        }
        
        .doodle-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            transition: transform 0.2s ease;
        }
        
        .doodle-actions button:hover {
            transform: scale(1.2);
        }
        
        .empty-state {
            text-align: center;
            color: var(--argo-blue);
            font-size: 10px;
            padding: 40px;
            grid-column: 1 / -1;
        }

        /* Enhanced Color Palette */
        .color-palette {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 40px;
            height: 40px;
            border: 3px solid var(--argo-dark-blue);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            box-shadow: 0 0 0 3px var(--argo-gold);
            transform: scale(1.2);
        }

        .color-swatch.active::after {
            content: '       ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* Brush Size Controls */
        .brush-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }

        .brush-size-btn {
            width: 30px;
            height: 30px;
            border: 2px solid var(--argo-blue);
            border-radius: 50%;
            background: var(--argo-white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .brush-size-btn:hover {
            background: var(--argo-light-blue);
        }

        .brush-size-btn.active {
            background: var(--argo-blue);
        }

        .brush-size-btn span {
            width: 4px;
            height: 4px;
            background: var(--argo-dark-blue);
            border-radius: 50%;
        }

        .brush-size-btn.medium span {
            width: 8px;
            height: 8px;
        }

        .brush-size-btn.large span {
            width: 12px;
            height: 12px;
        }

        .brush-size-btn.active span {
            background: var(--argo-white);
        }

        /* Drawing Tools */
        .drawing-tools {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .tool-btn {
            background: var(--argo-white);
            border: 3px solid var(--argo-blue);
            border-radius: 6px;
            padding: 10px 15px;
            font-size: 10px;
            color: var(--argo-dark-blue);
            cursor: pointer;
            transition: all 0.1s ease;
            font-family: 'Press Start 2P', monospace;
        }

        .tool-btn:hover {
            background: var(--argo-blue);
            color: var(--argo-white);
            transform: translateY(-2px);
        }

        .tool-btn:active {
            transform: translateY(0);
        }

        /* Parallax Layers */
        .parallax-layer {
            position: absolute;
            width: 110%;
            height: 110%;
            top: -5%;
            left: -5%;
        }

        .parallax-layer.back {
            z-index: 1;
            opacity: 0.3;
        }

        .parallax-layer.mid {
            z-index: 2;
            opacity: 0.5;
        }

        .parallax-layer.front {
            z-index: 3;
            opacity: 0.7;
        }

        /* Stats Dashboard Enhanced */
        .stats-dashboard {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(252, 252, 250, 0.95);
            background-image: 
                /* Subtle paper texture for stats panel */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='stats-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='2'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23stats-noise)' opacity='0.012'/%3E%3C/svg%3E");
            border: 3px solid var(--argo-blue);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            min-width: 200px;
        }

        .stats-title {
            font-size: 10px;
            color: var(--argo-dark-blue);
            margin-bottom: 10px;
            text-align: center;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 8px;
        }

        .stat-label {
            color: var(--argo-dark-blue);
        }

        .stat-value {
            color: var(--argo-gold);
            font-weight: bold;
        }

        /* Achievement Badge */
        .achievement-badge {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: var(--argo-white);
            border: 4px solid var(--argo-gold);
            border-radius: 12px;
            padding: 20px;
            z-index: 10002;
            text-align: center;
            animation: achievementPop 0.5s ease-out forwards;
        }

        @keyframes achievementPop {
            to {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .achievement-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .achievement-title {
            font-size: 12px;
            color: var(--argo-dark-blue);
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 8px;
            color: var(--argo-blue);
        }

        /* Loading States */
        .skeleton {
            background: linear-gradient(90deg, 
                var(--argo-light-blue) 25%, 
                var(--argo-gray) 50%, 
                var(--argo-light-blue) 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Night Mode Styles */
        body.night-mode {
            background: linear-gradient(180deg, #001a33 0%, #002244 100%);
        }

        body.night-mode .section {
            background: rgba(0, 26, 51, 0.5);
        }

        body.night-mode .time-message {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--argo-gold);
            color: var(--argo-white);
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 32px;
            }

            .level-indicator {
                display: none;
            }

            .stats-dashboard {
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }

            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
            
            .drawing-tools-panel {
                flex-direction: column;
                gap: 12px;
            }
            
            .size-buttons {
                justify-content: center;
            }
            
            .tool-actions {
                justify-content: center;
                width: 100%;
            }
            
            /* Adjust notebook lines for mobile */
            #enhancedCanvas {
                background-size: 100% 20px;
            }
            
            .message-display-area {
                background-size: auto, 100% 22px, auto;
            }
            
            #enhancedCanvas::after {
                left: 35px; /* Adjust margin line position */
            }
            
            .message-display-area::before {
                left: 30px; /* Adjust margin line position */
            }
        }
        
        /* ============================================
           MESSAGE DISPLAY AREA - PICTOCHAT STYLE
           ============================================ */
        .message-display-area {
            background-color: #FAF9F7;
            background-image: 
                /* Visible notebook lines */
                repeating-linear-gradient(
                    180deg,
                    transparent,
                    transparent 23px,
                    #D8DEE9 23px,
                    #D8DEE9 24px
                ),
                /* Paper texture pattern */
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 15px,
                    rgba(0, 0, 0, 0.008) 15px,
                    rgba(0, 0, 0, 0.008) 30px
                ),
                /* Depth gradient */
                linear-gradient(180deg, #FDFCFA 0%, #F7F6F4 100%);
            background-size: 100% 24px, auto, auto;
            border: 3px solid var(--argo-blue);
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            padding: 15px 15px 15px 60px; /* Extra padding for margin line */
            margin-top: 20px;
            position: relative;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.02);
        }
        
        /* Add vertical margin line to message area */
        .message-display-area::before {
            content: '';
            position: absolute;
            left: 45px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, #FFB5B9 0%, #FFB5B9 90%, transparent 100%);
            opacity: 0.35;
            pointer-events: none;
        }
        
        .message-bubble {
            background: #FAF9F7;
            background-image: 
                /* Subtle paper texture for message bubbles */
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Cfilter id='bubble-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2' numOctaves='1'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23bubble-noise)' opacity='0.01'/%3E%3C/svg%3E");
            border: 2px solid var(--argo-dark-blue);
            padding: 10px;
            margin-bottom: 10px;
            position: relative;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
        }
        
        .message-bubble.visible {
            opacity: 1;
            transform: scale(1);
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 8px;
            color: var(--argo-blue);
        }
        
        .message-content {
            background: var(--argo-white);
            border: 1px solid var(--argo-light-blue);
            padding: 5px;
        }
        
        .doodle-image {
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
            display: block;
        }
        
        /* Flying Message Animation */
        .flying-message {
            will-change: transform, left, top, opacity;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            border: 3px solid var(--argo-blue);
            background: var(--argo-white);
            z-index: 9999;
        }
        
        .flying-message img {
            display: block;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
        }
        
        /* Trail effect particles */
        .trail-particle {
            position: fixed;
            width: 4px;
            height: 4px;
            background: var(--argo-gold);
            pointer-events: none;
            z-index: 9998;
            animation: trailFade 0.5s ease-out forwards;
        }
        
        @keyframes trailFade {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.5);
            }
        }
        
        /* ============================================
           DS BOOT SEQUENCE STYLES
           ============================================ */
        .ds-boot-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            color: #FFFFFF;
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
        }
        
        .boot-stage {
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Warning Stage */
        .warning-title {
            font-size: 14px;
            margin-bottom: 30px;
            letter-spacing: 2px;
            color: #FFFFFF;
        }
        
        .warning-body {
            font-size: 8px;
            line-height: 1.8;
            opacity: 0.8;
            max-width: 500px;
            margin: 0 auto;
        }
        
        /* Logo Stage */
        .boot-logo {
            animation: logoAppear 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes logoAppear {
            from {
                opacity: 0;
                transform: scale(0.5) rotate(-10deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }
        
        .logo-text {
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 var(--argo-blue);
            letter-spacing: 4px;
            background: linear-gradient(180deg, #FFFFFF 0%, #E0E0E0 100%);
            -webkit-background-clip: text;
            background-clip: text;
        }
        
        .logo-subtitle {
            font-size: 10px;
            color: #CCCCCC;
            letter-spacing: 2px;
        }
        
        /* Loading Stage */
        .boot-loading {
            min-width: 400px;
        }
        
        .loading-bar-container {
            width: 100%;
            height: 24px;
            border: 3px solid #FFFFFF;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            background: #111111;
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--argo-blue) 0%, var(--argo-gold) 100%);
            animation: loadProgress 1.5s ease-out forwards;
        }
        
        @keyframes loadProgress {
            from { width: 0%; }
            to { width: 100%; }
        }
        
        .loading-text {
            font-size: 12px;
            letter-spacing: 2px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }
        
        /* Skip Button */
        .boot-skip-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: transparent;
            border: 2px solid #FFFFFF;
            color: #FFFFFF;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            padding: 10px 15px;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.3s ease;
        }
        
        .boot-skip-btn:hover {
            opacity: 1;
            background: #FFFFFF;
            color: #000000;
            transform: scale(1.05);
        }
        
        /* Fade out animation */
        .ds-boot-screen.fade-out {
            animation: bootFadeOut 0.8s ease-out forwards;
        }
        
        @keyframes bootFadeOut {
            to {
                opacity: 0;
                visibility: hidden;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* ============================================
           GENERAL PAPER TEXTURE HELPER CLASSES
           Apply these to any element needing paper feel
           ============================================ */
        
        /* Light paper texture */
        .paper-texture-light {
            background-color: #FAFAF8 !important;
            background-image: 
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='light-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='2'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23light-noise)' opacity='0.015'/%3E%3C/svg%3E") !important;
        }
        
        /* Medium paper texture */
        .paper-texture-medium {
            background-color: #F8F8F6 !important;
            background-image: 
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='250' height='250'%3E%3Cfilter id='medium-noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1' numOctaves='3'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23medium-noise)' opacity='0.025'/%3E%3C/svg%3E") !important;
        }
        
        /* Notebook lines overlay */
        .notebook-lines-overlay {
            background-image: 
                repeating-linear-gradient(
                    to bottom,
                    transparent,
                    transparent 23px,
                    rgba(216, 222, 233, 0.25) 23px,
                    rgba(216, 222, 233, 0.25) 24px
                ) !important;
            background-size: 100% 24px !important;
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                color: black;
            }

            .stats-dashboard,
            .level-indicator,
            #webglCanvas {
                display: none;
            }
        }
        
        /* ============================================
           PIXEL ICONS - Replace emojis with pixel art
           Added: Phase 3 Enhancement
           ============================================ */
        .pixel-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            vertical-align: middle;
            position: relative;
        }
        
        .pixel-icon.large {
            width: 24px;
            height: 24px;
        }
        
        .pixel-icon.small {
            width: 12px;
            height: 12px;
        }
        
        /* Heart icon */
        .pixel-icon.heart::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="3" y="4" width="2" height="2" fill="%23FF0000"/><rect x="5" y="3" width="2" height="2" fill="%23FF0000"/><rect x="7" y="3" width="2" height="2" fill="%23FF0000"/><rect x="9" y="4" width="2" height="2" fill="%23FF0000"/><rect x="11" y="4" width="2" height="2" fill="%23FF0000"/><rect x="2" y="6" width="2" height="2" fill="%23FF0000"/><rect x="4" y="6" width="2" height="2" fill="%23FF0000"/><rect x="6" y="6" width="2" height="2" fill="%23FF0000"/><rect x="8" y="6" width="2" height="2" fill="%23FF0000"/><rect x="10" y="6" width="2" height="2" fill="%23FF0000"/><rect x="12" y="6" width="2" height="2" fill="%23FF0000"/><rect x="3" y="8" width="2" height="2" fill="%23FF0000"/><rect x="5" y="8" width="2" height="2" fill="%23FF0000"/><rect x="7" y="8" width="2" height="2" fill="%23FF0000"/><rect x="9" y="8" width="2" height="2" fill="%23FF0000"/><rect x="11" y="8" width="2" height="2" fill="%23FF0000"/><rect x="5" y="10" width="2" height="2" fill="%23FF0000"/><rect x="7" y="10" width="2" height="2" fill="%23FF0000"/><rect x="9" y="10" width="2" height="2" fill="%23FF0000"/><rect x="7" y="12" width="2" height="2" fill="%23FF0000"/></svg>');
            background-size: contain;
        }
        
        /* Love icon */
        .pixel-icon.love::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="3" y="3" width="2" height="2" fill="%23FF66CC"/><rect x="11" y="3" width="2" height="2" fill="%23FF66CC"/><rect x="2" y="5" width="2" height="2" fill="%23FF66CC"/><rect x="4" y="5" width="2" height="2" fill="%23FF66CC"/><rect x="10" y="5" width="2" height="2" fill="%23FF66CC"/><rect x="12" y="5" width="2" height="2" fill="%23FF66CC"/><rect x="3" y="7" width="10" height="2" fill="%23FF66CC"/><rect x="4" y="9" width="8" height="2" fill="%23FF66CC"/><rect x="5" y="11" width="6" height="2" fill="%23FF66CC"/><rect x="7" y="13" width="2" height="2" fill="%23FF66CC"/></svg>');
            background-size: contain;
        }
        
        /* Fire icon */
        .pixel-icon.fire::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="7" y="2" width="2" height="2" fill="%23FF6600"/><rect x="6" y="4" width="2" height="2" fill="%23FF6600"/><rect x="8" y="4" width="2" height="2" fill="%23FF6600"/><rect x="5" y="6" width="2" height="2" fill="%23FFCC00"/><rect x="7" y="6" width="2" height="2" fill="%23FF6600"/><rect x="9" y="6" width="2" height="2" fill="%23FFCC00"/><rect x="4" y="8" width="2" height="2" fill="%23FFCC00"/><rect x="6" y="8" width="2" height="2" fill="%23FF0000"/><rect x="8" y="8" width="2" height="2" fill="%23FF0000"/><rect x="10" y="8" width="2" height="2" fill="%23FFCC00"/><rect x="4" y="10" width="2" height="2" fill="%23FF0000"/><rect x="6" y="10" width="2" height="2" fill="%23FF0000"/><rect x="8" y="10" width="2" height="2" fill="%23FF0000"/><rect x="10" y="10" width="2" height="2" fill="%23FF0000"/><rect x="5" y="12" width="2" height="2" fill="%23FF0000"/><rect x="7" y="12" width="2" height="2" fill="%23FF0000"/><rect x="9" y="12" width="2" height="2" fill="%23FF0000"/></svg>');
            background-size: contain;
        }
        
        /* Laugh icon */
        .pixel-icon.laugh::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="4" y="3" width="8" height="2" fill="%23FFCC00"/><rect x="2" y="5" width="2" height="2" fill="%23FFCC00"/><rect x="12" y="5" width="2" height="2" fill="%23FFCC00"/><rect x="2" y="7" width="2" height="2" fill="%23FFCC00"/><rect x="5" y="7" width="2" height="2" fill="%23000000"/><rect x="9" y="7" width="2" height="2" fill="%23000000"/><rect x="12" y="7" width="2" height="2" fill="%23FFCC00"/><rect x="2" y="9" width="2" height="2" fill="%23FFCC00"/><rect x="4" y="10" width="8" height="2" fill="%23000000"/><rect x="12" y="9" width="2" height="2" fill="%23FFCC00"/><rect x="4" y="11" width="8" height="2" fill="%23FFCC00"/></svg>');
            background-size: contain;
        }
        
        /* Animated effects for pixel icons */
        @keyframes pixel-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        @keyframes pixel-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        
        .pixel-icon.heart:hover {
            animation: pixel-pulse 0.6s ease infinite;
        }
        
        .pixel-icon.fire {
            animation: pixel-bounce 1s ease infinite;
        }
        
        .reaction-btn .pixel-icon {
            margin-right: 3px;
        }
        
        /* Shake animation for already-reacted buttons */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }
        
        /* My Doodles section styling */
        .my-doodles-section {
            background: var(--argo-gray);
            padding: 40px 20px;
            min-height: 200px;
        }
        
        .my-doodles-title {
            font-size: 20px;
            color: var(--argo-dark-blue);
            text-align: center;
            margin-bottom: 10px;
        }
        
        /* Additional pixel icons for UI elements */
        .pixel-icon.checkmark::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="2" y="8" width="2" height="2" fill="%23FFFFFF"/><rect x="4" y="10" width="2" height="2" fill="%23FFFFFF"/><rect x="6" y="12" width="2" height="2" fill="%23FFFFFF"/><rect x="8" y="10" width="2" height="2" fill="%23FFFFFF"/><rect x="10" y="8" width="2" height="2" fill="%23FFFFFF"/><rect x="12" y="6" width="2" height="2" fill="%23FFFFFF"/><rect x="14" y="4" width="2" height="2" fill="%23FFFFFF"/></svg>');
            background-size: contain;
        }
        
        .pixel-icon.share::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="10" y="2" width="4" height="4" fill="%230066CC"/><rect x="8" y="4" width="2" height="2" fill="%230066CC"/><rect x="6" y="6" width="2" height="2" fill="%230066CC"/><rect x="2" y="6" width="4" height="4" fill="%230066CC"/><rect x="6" y="8" width="2" height="2" fill="%230066CC"/><rect x="8" y="10" width="2" height="2" fill="%230066CC"/><rect x="10" y="10" width="4" height="4" fill="%230066CC"/></svg>');
            background-size: contain;
        }
        
        .pixel-icon.link::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="6" y="4" width="2" height="2" fill="%23000000"/><rect x="4" y="6" width="2" height="2" fill="%23000000"/><rect x="6" y="8" width="2" height="2" fill="%23000000"/><rect x="8" y="6" width="2" height="2" fill="%23000000"/><rect x="10" y="8" width="2" height="2" fill="%23000000"/><rect x="8" y="10" width="2" height="2" fill="%23000000"/><rect x="10" y="12" width="2" height="2" fill="%23000000"/><rect x="12" y="10" width="2" height="2" fill="%23000000"/></svg>');
            background-size: contain;
        }
        
        /* Doodle info styling */
        .doodle-info {
            padding: 8px;
            font-size: 8px;
            color: var(--argo-blue);
            text-align: center;
            border-top: 1px solid var(--argo-light-blue);
        }
    </style>
</head>
<body>
    <!-- WebGL Canvas for CRT Effect -->
    <canvas id="webglCanvas"></canvas>

    <!-- Scroll Progress -->
    <div class="scroll-progress">
        <div class="scroll-progress-bar" id="scrollProgress"></div>
    </div>

    <!-- Level Indicator -->
    <div class="level-indicator">
        <div class="level-dot active" data-section="Hero"></div>
        <div class="level-dot" data-section="Problem"></div>
        <div class="level-dot" data-section="Solution"></div>
        <div class="level-dot" data-section="Gallery"></div>
        <div class="level-dot" data-section="Canvas"></div>
        <div class="level-dot" data-section="CTA"></div>
    </div>



    <!-- Stats Dashboard -->
    <div class="stats-dashboard">
        <div class="stats-title">LIVE STATS</div>
        <div class="stat-row">
            <span class="stat-label">Doodles:</span>
            <span class="stat-value" id="doodleCount">3,421</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Time:</span>
            <span class="stat-value" id="timeSpent">0:00</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Level:</span>
            <span class="stat-value" id="currentLevel">1/5</span>
        </div>
    </div>

    <!-- Hero Section -->
    <section class="section hero-section">
        <div class="section-content">
            <h1 class="hero-title glitch-text" data-text="ARGO">ARGO</h1>
            <div class="time-message" id="timeMessage">
                <p id="dynamicMessage">Welcome! Loading personalized message...</p>
            </div>
            <div class="scroll-element">
                <p style="text-align: center; font-size: 12px; color: var(--argo-dark-blue); margin-top: 30px;">
                    Your AI Voice Clone That Negotiates For You
                </p>
            </div>
        </div>
    </section>

    <!-- Problem Section -->
    <section class="section">
        <div class="section-content">
            <div class="scroll-element">
                <h2 style="font-size: 24px; color: var(--argo-dark-blue); text-align: center; margin-bottom: 40px;">
                    The Phone Call Problem
                </h2>
            </div>
            <div class="scroll-element" style="animation-delay: 0.2s;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                    <div class="pixelate-in" style="background: white; border: 3px solid #FF4444; border-radius: 8px; padding: 20px;">
                        <h3 style="font-size: 10px; color: #FF4444; margin-bottom: 10px;">43 HOURS/YEAR</h3>
                        <p style="font-size: 8px; line-height: 1.5;">Average time wasted on hold</p>
                    </div>
                    <div class="pixelate-in" style="background: white; border: 3px solid #FF4444; border-radius: 8px; padding: 20px; animation-delay: 0.1s;">
                        <h3 style="font-size: 10px; color: #FF4444; margin-bottom: 10px;">$2,400 LOST</h3>
                        <p style="font-size: 8px; line-height: 1.5;">In missed negotiation savings</p>
                    </div>
                    <div class="pixelate-in" style="background: white; border: 3px solid #FF4444; border-radius: 8px; padding: 20px; animation-delay: 0.2s;">
                        <h3 style="font-size: 10px; color: #FF4444; margin-bottom: 10px;">87% STRESS</h3>
                        <p style="font-size: 8px; line-height: 1.5;">From dealing with companies</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Solution Section -->
    <section class="section">
        <div class="section-content">
            <div class="scroll-element">
                <h2 style="font-size: 24px; color: var(--argo-gold); text-align: center; margin-bottom: 40px;">
                    Enter Argo: Your Voice, Automated
                </h2>
            </div>
            <div class="scroll-element" style="animation-delay: 0.3s;">
                <div style="text-align: center;">
                    <div class="glitch-text" data-text="VOICE CLONING" style="font-size: 16px; color: var(--argo-blue); margin: 20px;">
                        VOICE CLONING
                    </div>
                    <div class="glitch-text" data-text="BILL NEGOTIATION" style="font-size: 16px; color: var(--argo-blue); margin: 20px;">
                        BILL NEGOTIATION
                    </div>
                    <div class="glitch-text" data-text="24/7 AVAILABILITY" style="font-size: 16px; color: var(--argo-blue); margin: 20px;">
                        24/7 AVAILABILITY
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Community Gallery Section -->
    <section class="section gallery-section">
        <div class="section-content">
            <div class="gallery-header">
                <h2 class="gallery-title">Community Creations</h2>
                <p style="font-size: 10px; color: var(--argo-blue);">
                    Draw, share, and vote for your favorites!
                </p>
            </div>
            <div class="gallery-grid" id="galleryGrid">
                <!-- Dynamically loaded doodles will appear here -->
            </div>
            <div style="text-align: center;">
                <button class="tool-btn" onclick="loadMoreDoodles()">LOAD MORE</button>
            </div>
        </div>
    </section>

    <!-- Enhanced Drawing Canvas Section -->
    <section class="section">
        <div class="section-content">
            <div class="canvas-container">
                <h3 style="font-size: 14px; color: var(--argo-dark-blue); text-align: center; margin-bottom: 20px;">
                    Create Your Doodle
                </h3>
                <canvas id="enhancedCanvas"></canvas>
                <!-- Pictochat Drawing Tools Panel -->
                <div class="drawing-tools-panel">
                    <!-- Color Palette -->
                    <div class="color-palette-section">
                        <div class="palette-label">COLOR</div>
                        <div class="color-grid">
                            <button class="color-swatch active" data-color="#000000" 
                                    style="background-color: #000000;" 
                                    aria-label="Black"></button>
                            <button class="color-swatch" data-color="#FF0000" 
                                    style="background-color: #FF0000;" 
                                    aria-label="Red"></button>
                            <button class="color-swatch" data-color="#0066CC" 
                                    style="background-color: #0066CC;" 
                                    aria-label="Blue"></button>
                            <button class="color-swatch" data-color="#00CC00" 
                                    style="background-color: #00CC00;" 
                                    aria-label="Green"></button>
                            <button class="color-swatch" data-color="#FFCC00" 
                                    style="background-color: #FFCC00;" 
                                    aria-label="Yellow"></button>
                            <button class="color-swatch" data-color="#FF6600" 
                                    style="background-color: #FF6600;" 
                                    aria-label="Orange"></button>
                            <button class="color-swatch" data-color="#FF66CC" 
                                    style="background-color: #FF66CC;" 
                                    aria-label="Pink"></button>
                            <button class="color-swatch" data-color="#6600CC" 
                                    style="background-color: #6600CC;" 
                                    aria-label="Purple"></button>
                        </div>
                    </div>
                    
                    <!-- Brush Size -->
                    <div class="brush-size-selector">
                        <div class="palette-label">SIZE</div>
                        <div class="size-buttons">
                            <button class="size-btn active" data-size="small" aria-label="Small brush">
                                <span class="size-dot small"></span>
                            </button>
                            <button class="size-btn" data-size="medium" aria-label="Medium brush">
                                <span class="size-dot medium"></span>
                            </button>
                            <button class="size-btn" data-size="large" aria-label="Large brush">
                                <span class="size-dot large"></span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Tools -->
                    <div class="tool-actions">
                        <button class="tool-btn" data-tool="pen" id="penBtn" aria-label="Pen">
                            PEN
                        </button>
                        <button class="tool-btn" data-tool="eraser" id="eraserBtn" aria-label="Eraser">
                            ERASE
                        </button>
                        <button class="tool-btn" data-tool="clear" id="clearBtn" aria-label="Clear canvas">
                            CLEAR
                        </button>
                    </div>
                    
                    <!-- Actions -->
                    <div class="tool-actions">
                        <button class="tool-btn" id="sendBtn" onclick="sendDoodleMessage()">
                            SEND
                        </button>
                        <button class="tool-btn" id="saveBtn" onclick="saveDoodleAsImage()">
                            SAVE
                        </button>
                    </div>
                </div>
                
                <!-- Message Display Area for Pictochat -->
                <div id="messageDisplayArea" class="message-display-area"></div>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="section">
        <div class="section-content">
            <div style="text-align: center;">
                <h2 style="font-size: 28px; color: var(--argo-dark-blue); margin-bottom: 30px;">
                    Join the Waiting List!
                </h2>
                <a href="https://docs.google.com/forms/d/1TVZkqAKaJtECmmKssGcis6rZs0xFsCfk60PdqwV1tHQ" class="tool-btn" style="font-size: 16px; padding: 20px 40px; background: linear-gradient(180deg, var(--argo-gold) 0%, var(--argo-dark-gold) 100%); color: white; border-width: 4px;">
                    GET EARLY ACCESS
                </a>
                <p style="margin-top: 40px; font-size: 10px; color: var(--argo-blue);">
                    Limited spots available        Launching Q1 2026
                </p>
            </div>
        </div>
    </section>

    <!-- Achievement Badge (Hidden by default) -->
    <div class="achievement-badge" id="achievementBadge" style="display: none;">
        <div class="achievement-icon">Ã¢Ëœâ€¦</div>
        <div class="achievement-title">Achievement Unlocked!</div>
        <div class="achievement-desc" id="achievementDesc">Master Artist</div>
    </div>

    <script>
        // Global Configuration
        const CONFIG = {
            webglEnabled: true,
            performanceMode: 'high',
            animationsEnabled: true,
            particlesEnabled: true,
            audioEnabled: true,
            apiBaseUrl: '/api', // Update with actual API endpoint
            wsUrl: 'wss://your-server.com/ws' // Update with actual WebSocket endpoint
        };

        // Device Performance Detection
        const devicePerformance = {
            cores: navigator.hardwareConcurrency || 4,
            memory: navigator.deviceMemory || 4,
            connection: navigator.connection?.effectiveType || '4g',
            
            isHighEnd() {
                return this.cores >= 4 && this.memory >= 4;
            },
            
            isMidRange() {
                return this.cores >= 2 && this.memory >= 2;
            },
            
            isLowEnd() {
                return this.cores < 2 || this.memory < 2;
            }
        };
        
        // ============================================
        // PIXEL ICON GENERATOR - Creates pixel icons programmatically
        // Added: Phase 3 Enhancement
        // ============================================
        class PixelIconGenerator {
            static createIcon(type, size = 16, color = '#0066CC') {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                
                const scale = size / 16;
                ctx.scale(scale, scale);
                ctx.fillStyle = color;
                
                switch(type) {
                    case 'heart':
                        this.drawHeart(ctx);
                        break;
                    case 'fire':
                        this.drawFire(ctx);
                        break;
                    case 'thumbsUp':
                        this.drawThumbsUp(ctx);
                        break;
                    case 'laugh':
                        this.drawLaugh(ctx);
                        break;
                    case 'robot':
                        this.drawRobot(ctx);
                        break;
                    case 'phone':
                        this.drawPhone(ctx);
                        break;
                    case 'check':
                        this.drawCheck(ctx);
                        break;
                    case 'download':
                        this.drawDownload(ctx);
                        break;
                    case 'trash':
                        this.drawTrash(ctx);
                        break;
                    case 'link':
                        this.drawLink(ctx);
                        break;
                    case 'sparkle':
                        this.drawSparkle(ctx);
                        break;
                    case 'twitter':
                        this.drawTwitter(ctx);
                        break;
                    case 'facebook':
                        this.drawFacebook(ctx);
                        break;
                    default:
                        this.drawDefault(ctx);
                }
                
                return canvas.toDataURL();
            }
            
            static drawHeart(ctx) {
                const pixels = [
                    [0,0,1,1,0,0,0,1,1,0,0,0],
                    [0,1,1,1,1,0,1,1,1,1,0,0],
                    [1,1,1,1,1,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1,1,1,1,0],
                    [0,1,1,1,1,1,1,1,1,1,0,0],
                    [0,0,1,1,1,1,1,1,1,0,0,0],
                    [0,0,0,1,1,1,1,1,0,0,0,0],
                    [0,0,0,0,1,1,1,0,0,0,0,0],
                    [0,0,0,0,0,1,0,0,0,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawFire(ctx) {
                const pixels = [
                    [0,0,0,0,1,0,0,0,0,0],
                    [0,0,0,1,1,0,0,0,0,0],
                    [0,0,0,1,1,1,0,0,0,0],
                    [0,0,1,1,1,1,0,0,0,0],
                    [0,0,1,1,1,1,1,0,0,0],
                    [0,1,1,1,1,1,1,0,0,0],
                    [0,1,1,1,1,1,1,1,0,0],
                    [1,1,1,1,1,1,1,1,0,0],
                    [1,1,1,1,1,1,1,1,1,0],
                    [0,1,1,1,1,1,1,1,0,0],
                    [0,0,1,1,1,1,1,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawThumbsUp(ctx) {
                const pixels = [
                    [0,0,0,1,1,0,0,0,0],
                    [0,0,0,1,1,0,0,0,0],
                    [0,0,0,1,1,0,0,0,0],
                    [0,0,0,1,1,0,0,0,0],
                    [1,1,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1,1],
                    [0,1,1,1,1,1,1,1,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawLaugh(ctx) {
                // Simple smiley face
                const pixels = [
                    [0,0,1,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1,1],
                    [1,1,0,1,1,1,0,1,1],
                    [1,1,1,1,1,1,1,1,1],
                    [1,1,0,1,1,1,0,1,1],
                    [1,1,1,0,0,0,1,1,1],
                    [0,1,1,1,1,1,1,1,0],
                    [0,0,1,1,1,1,1,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawRobot(ctx) {
                const pixels = [
                    [0,0,0,1,0,0,0],
                    [0,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1],
                    [1,0,1,1,1,0,1],
                    [1,1,1,1,1,1,1],
                    [1,1,0,0,0,1,1],
                    [0,1,1,1,1,1,0],
                    [0,0,1,1,1,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawPhone(ctx) {
                const pixels = [
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1],
                    [1,1,1,1,1,1,1,1],
                    [1,1,1,0,0,1,1,1],
                    [0,1,1,1,1,1,1,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawCheck(ctx) {
                const pixels = [
                    [0,0,0,0,0,0,1,0],
                    [0,0,0,0,0,1,1,0],
                    [0,0,0,0,1,1,0,0],
                    [1,0,0,1,1,0,0,0],
                    [1,1,1,1,0,0,0,0],
                    [0,1,1,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawDownload(ctx) {
                const pixels = [
                    [0,0,1,1,1,1,0,0],
                    [0,0,1,1,1,1,0,0],
                    [0,0,1,1,1,1,0,0],
                    [1,1,1,1,1,1,1,1],
                    [0,1,1,1,1,1,1,0],
                    [0,0,1,1,1,1,0,0],
                    [0,0,0,1,1,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawTrash(ctx) {
                const pixels = [
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1],
                    [0,1,0,1,0,1,0,0],
                    [0,1,0,1,0,1,0,0],
                    [0,1,0,1,0,1,0,0],
                    [0,1,0,1,0,1,0,0],
                    [0,1,1,1,1,1,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawLink(ctx) {
                const pixels = [
                    [0,1,1,0,0,1,1,0],
                    [1,0,0,1,1,0,0,1],
                    [1,0,0,1,1,0,0,1],
                    [0,1,1,1,1,1,1,0],
                    [0,0,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,0],
                    [1,0,0,1,1,0,0,1],
                    [1,0,0,1,1,0,0,1],
                    [0,1,1,0,0,1,1,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawSparkle(ctx) {
                const pixels = [
                    [0,0,0,1,0,0,0],
                    [0,0,1,1,1,0,0],
                    [0,1,0,1,0,1,0],
                    [1,1,1,1,1,1,1],
                    [0,1,0,1,0,1,0],
                    [0,0,1,1,1,0,0],
                    [0,0,0,1,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawTwitter(ctx) {
                // Simple bird shape for Twitter
                const pixels = [
                    [0,0,0,1,1,1,0,0],
                    [0,0,1,1,1,1,1,0],
                    [0,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,0,0],
                    [1,1,1,1,1,0,0,0],
                    [0,1,1,1,0,0,0,0],
                    [0,0,1,0,0,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawFacebook(ctx) {
                // Simple F shape for Facebook
                const pixels = [
                    [1,1,1,1,1,1,1],
                    [1,1,0,0,0,0,0],
                    [1,1,0,0,0,0,0],
                    [1,1,1,1,1,0,0],
                    [1,1,0,0,0,0,0],
                    [1,1,0,0,0,0,0],
                    [1,1,0,0,0,0,0]
                ];
                this.drawPixels(ctx, pixels);
            }
            
            static drawDefault(ctx) {
                // Simple square for unknown icons
                ctx.fillRect(2, 2, 12, 12);
            }
            
            static drawPixels(ctx, pixels) {
                pixels.forEach((row, y) => {
                    row.forEach((pixel, x) => {
                        if (pixel === 1) {
                            ctx.fillRect(x * 2, y * 1.5, 2, 1.5);
                        }
                    });
                });
            }
        }
        
        // ============================================
        // DOODLE GENERATOR - Creates programmatic Pictochat-style doodles
        // Added: Phase 3 Enhancement - NO BACKEND VERSION
        // Enhanced with realistic hand-drawn effects
        // ============================================
        class DoodleGenerator {
            constructor(width = 200, height = 150) {
                this.width = width;
                this.height = height;
                this.colors = ['#000000', '#FF0000', '#0066CC', '#00CC00', 
                              '#FFCC00', '#FF6600', '#FF66CC', '#6600CC'];
                this.penSizes = [2, 5, 8];
                // Signatures for random doodles
                this.signatures = ['~A', 'JK', 'XD', ':)', 'M', 'S.T.', '!!!', '<3', 'TY', 'hi!'];
            }
            
            generate(type) {
                const canvas = document.createElement('canvas');
                canvas.width = this.width;
                canvas.height = this.height;
                const ctx = canvas.getContext('2d');
                
                // White background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, this.width, this.height);
                
                // Disable smoothing for pixel-perfect look
                ctx.imageSmoothingEnabled = false;
                
                // Generate based on type
                switch(type) {
                    case 'robot':
                        this.drawRobot(ctx);
                        break;
                    case 'phone':
                        this.drawPhone(ctx);
                        break;
                    case 'ai':
                        this.drawAI(ctx);
                        break;
                    case 'text':
                        this.drawText(ctx);
                        break;
                    case 'abstract':
                        this.drawAbstract(ctx);
                        break;
                }
                
                // Optionally add eraser marks (20% chance)
                if (Math.random() < 0.2) {
                    this.addEraserMarks(ctx);
                }
                
                return canvas.toDataURL();
            }
            
            // Helper method: Draw organic line with hand-drawn wobble
            drawOrganicLine(ctx, x1, y1, x2, y2, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness + (Math.random() - 0.5) * 1.5; // Vary thickness
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(x1 + (Math.random() - 0.5) * 2, y1 + (Math.random() - 0.5) * 2);
                
                // Add control points with jitter for natural curve
                const segments = Math.max(3, Math.floor(Math.hypot(x2 - x1, y2 - y1) / 20));
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 3;
                    const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 3;
                    ctx.lineTo(x, y);
                }
                
                ctx.stroke();
                
                // Sometimes add a second stroke for "correction" effect
                if (Math.random() < 0.1) {
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(x1 + 1, y1 + 1);
                    ctx.lineTo(x2 + 1, y2 + 1);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
            
            // Helper method: Draw wobbly circle (imperfect)
            drawWobblyCircle(ctx, cx, cy, radius, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness + (Math.random() - 0.5);
                ctx.lineCap = 'round';
                ctx.beginPath();
                
                const points = 16 + Math.floor(Math.random() * 8);
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const jitter = (Math.random() - 0.5) * (radius * 0.15);
                    const r = radius + jitter;
                    const x = cx + Math.cos(angle) * r + (Math.random() - 0.5) * 2;
                    const y = cy + Math.sin(angle) * r + (Math.random() - 0.5) * 2;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                // Don't always close perfectly
                if (Math.random() > 0.2) {
                    ctx.closePath();
                }
                ctx.stroke();
            }
            
            // Helper method: Draw wobbly rectangle
            drawWobblyRect(ctx, x, y, width, height, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness + (Math.random() - 0.5);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                
                // Start point with slight offset
                const startX = x + (Math.random() - 0.5) * 3;
                const startY = y + (Math.random() - 0.5) * 3;
                ctx.moveTo(startX, startY);
                
                // Top edge
                this.drawWobblyEdge(ctx, startX, startY, x + width, y);
                
                // Right edge
                this.drawWobblyEdge(ctx, x + width, y, x + width, y + height);
                
                // Bottom edge
                this.drawWobblyEdge(ctx, x + width, y + height, x, y + height);
                
                // Left edge (might not connect perfectly)
                if (Math.random() > 0.1) {
                    this.drawWobblyEdge(ctx, x, y + height, startX, startY);
                }
                
                ctx.stroke();
            }
            
            // Helper for drawing wobbly edge
            drawWobblyEdge(ctx, x1, y1, x2, y2) {
                const segments = 3 + Math.floor(Math.random() * 2);
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 4;
                    const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 4;
                    ctx.lineTo(x, y);
                }
            }
            
            // Draw handwritten-style text
            drawHandwrittenText(ctx, text, x, y, color) {
                ctx.fillStyle = color;
                ctx.font = 'bold 14px "Press Start 2P", monospace';
                
                // Add slight rotation for natural look
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate((Math.random() - 0.5) * 0.05);
                
                for (let i = 0; i < text.length; i++) {
                    const jitterX = (Math.random() - 0.5) * 2;
                    const jitterY = (Math.random() - 0.5) * 2;
                    ctx.fillText(text[i], i * 14 + jitterX, jitterY);
                }
                
                ctx.restore();
            }
            
            // Draw a star shape
            drawStar(ctx, cx, cy, size, color) {
                ctx.fillStyle = color;
                const points = 5;
                const outer = size;
                const inner = size * 0.4;
                
                ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const r = i % 2 === 0 ? outer : inner;
                    const x = cx + Math.cos(angle) * r + (Math.random() - 0.5) * 1;
                    const y = cy + Math.sin(angle) * r + (Math.random() - 0.5) * 1;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
            }
            
            // Add eraser marks effect
            addEraserMarks(ctx) {
                const numMarks = 1 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < numMarks; i++) {
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    const size = 10 + Math.random() * 20;
                    
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                    
                    // Create eraser stroke
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const offsetX = x + (Math.random() - 0.5) * size;
                        const offsetY = y + (Math.random() - 0.5) * size;
                        if (j === 0) ctx.moveTo(offsetX, offsetY);
                        else ctx.lineTo(offsetX, offsetY);
                    }
                    ctx.lineWidth = 8 + Math.random() * 8;
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Add signature to corner
            addSignature(ctx) {
                const signature = this.signatures[Math.floor(Math.random() * this.signatures.length)];
                ctx.fillStyle = this.randomColor();
                ctx.font = '8px monospace';
                ctx.globalAlpha = 0.7;
                ctx.fillText(signature, this.width - 30, this.height - 10);
                ctx.globalAlpha = 1;
            }
            
            drawRobot(ctx) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const color = this.randomColor();
                const size = this.randomPenSize();
                
                // Head (wobbly square)
                this.drawWobblyRect(ctx, centerX - 25, centerY - 30, 50, 45, color, size);
                
                // Eyes
                this.drawWobblyCircle(ctx, centerX - 12, centerY - 15, 5, color, size);
                this.drawWobblyCircle(ctx, centerX + 12, centerY - 15, 5, color, size);
                
                // Antenna
                this.drawOrganicLine(ctx, centerX, centerY - 30, centerX, centerY - 45, color, size);
                this.drawWobblyCircle(ctx, centerX, centerY - 45, 4, color, size);
                
                // Mouth (simple line)
                this.drawOrganicLine(ctx, centerX - 8, centerY, centerX + 8, centerY, color, size);
                
                // Body (sometimes)
                if (Math.random() > 0.3) {
                    this.drawWobblyRect(ctx, centerX - 20, centerY + 15, 40, 35, color, size);
                    // Arms
                    this.drawOrganicLine(ctx, centerX - 20, centerY + 25, centerX - 35, centerY + 30, color, size);
                    this.drawOrganicLine(ctx, centerX + 20, centerY + 25, centerX + 35, centerY + 30, color, size);
                }
                
                // Add signature sometimes
                if (Math.random() < 0.15) {
                    this.addSignature(ctx);
                }
            }
            
            drawPhone(ctx) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const color = this.randomColor();
                const size = this.randomPenSize();
                
                // Phone body
                this.drawWobblyRect(ctx, centerX - 20, centerY - 35, 40, 70, color, size);
                
                // Screen
                this.drawWobblyRect(ctx, centerX - 15, centerY - 25, 30, 40, color, size - 1);
                
                // Button
                this.drawWobblyCircle(ctx, centerX, centerY + 25, 4, color, size);
                
                // Signal waves
                if (Math.random() > 0.5) {
                    this.drawOrganicLine(ctx, centerX + 25, centerY - 20, centerX + 35, centerY - 25, color, size - 1);
                    this.drawOrganicLine(ctx, centerX + 25, centerY - 10, centerX + 35, centerY - 15, color, size - 1);
                    this.drawOrganicLine(ctx, centerX + 25, centerY, centerX + 35, centerY - 5, color, size - 1);
                }
            }
            
            drawAI(ctx) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const color = this.randomColor();
                const size = this.randomPenSize();
                
                // Circuit board pattern
                const gridSize = 15;
                for (let i = 0; i < 4; i++) {
                    const x = centerX - 30 + i * 20 + (Math.random() - 0.5) * 5;
                    const y = centerY - 20 + (Math.random() - 0.5) * 10;
                    
                    // Draw circuit nodes
                    this.drawWobblyCircle(ctx, x, y, 3, color, size);
                    
                    // Connect with lines
                    if (i < 3) {
                        this.drawOrganicLine(ctx, x + 3, y, x + 17, y, color, size - 1);
                    }
                }
                
                // Central chip
                this.drawWobblyRect(ctx, centerX - 15, centerY - 10, 30, 20, color, size);
                
                // Add "AI" text
                ctx.fillStyle = color;
                ctx.font = 'bold 12px monospace';
                ctx.fillText('AI', centerX - 7, centerY + 3);
                
                // Additional circuit lines
                for (let i = 0; i < 3; i++) {
                    const startX = centerX - 15;
                    const startY = centerY - 10 + i * 10;
                    this.drawOrganicLine(ctx, startX - 20, startY, startX, startY, color, size - 1);
                    this.drawOrganicLine(ctx, centerX + 15, startY, centerX + 35, startY, color, size - 1);
                }
            }
            
            drawText(ctx) {
                const phrases = ['ARGO', 'AI', 'HELLO', 'CALL ME', 'HI!', 'HELP', 'YES!', 'WOW', 'COOL'];
                const text = phrases[Math.floor(Math.random() * phrases.length)];
                const color = this.randomColor();
                
                // Position text with some randomness
                const x = 20 + Math.random() * 20;
                const y = this.height / 2 + (Math.random() - 0.5) * 30;
                
                this.drawHandwrittenText(ctx, text, x, y, color);
                
                // Add decorations sometimes
                if (Math.random() > 0.5) {
                    // Underline
                    this.drawOrganicLine(ctx, x, y + 5, x + text.length * 12, y + 5, color, 2);
                }
                
                if (Math.random() > 0.7) {
                    // Add stars around text
                    this.drawStar(ctx, x - 15, y - 10, 3, color);
                    this.drawStar(ctx, x + text.length * 12 + 10, y - 10, 3, color);
                }
            }
            
            drawAbstract(ctx) {
                const color = this.randomColor();
                const size = this.randomPenSize();
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                const abstracts = ['star', 'heart', 'arrows', 'spiral', 'zigzag'];
                const type = abstracts[Math.floor(Math.random() * abstracts.length)];
                
                switch(type) {
                    case 'star':
                        this.drawStar(ctx, centerX, centerY, 20, color);
                        break;
                    case 'heart':
                        this.drawHeart(ctx, centerX, centerY, color, size);
                        break;
                    case 'arrows':
                        this.drawArrow(ctx, centerX - 30, centerY, centerX + 30, centerY, color, size);
                        break;
                    case 'spiral':
                        this.drawSpiral(ctx, centerX, centerY, color, size);
                        break;
                    case 'zigzag':
                        this.drawZigzag(ctx, centerX - 40, centerY, centerX + 40, centerY, color, size);
                        break;
                }
                
                // Add random decorations
                for (let i = 0; i < 3; i++) {
                    if (Math.random() > 0.6) {
                        const x = Math.random() * this.width;
                        const y = Math.random() * this.height;
                        this.drawStar(ctx, x, y, 2, color);
                    }
                }
            }
            
            // Helper drawing functions with hand-drawn imperfections
            drawOrganicLine(ctx, x1, y1, x2, y2, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness + (Math.random() * 2 - 1); // Vary thickness
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                
                // Add wobble via control points
                const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * 5;
                const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 5;
                
                ctx.quadraticCurveTo(midX, midY, x2, y2);
                ctx.stroke();
            }
            
            drawWobblyCircle(ctx, cx, cy, radius, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                
                const points = 16;
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const jitter = (Math.random() - 0.5) * 3;
                    const r = radius + jitter;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            drawWobblyRect(ctx, x, y, w, h, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                
                // Top line with wobble
                this.drawOrganicLine(ctx, x, y, x + w, y, color, thickness);
                // Right line
                this.drawOrganicLine(ctx, x + w, y, x + w, y + h, color, thickness);
                // Bottom line
                this.drawOrganicLine(ctx, x + w, y + h, x, y + h, color, thickness);
                // Left line
                this.drawOrganicLine(ctx, x, y + h, x, y, color, thickness);
            }
            
            drawHandwrittenText(ctx, text, x, y, color) {
                ctx.font = 'bold 14px "Press Start 2P", monospace';
                ctx.fillStyle = color;
                
                // Add character-by-character with slight position variation
                for (let i = 0; i < text.length; i++) {
                    const jitterX = (Math.random() - 0.5) * 1;
                    const jitterY = (Math.random() - 0.5) * 1;
                    ctx.fillText(text[i], x + i * 12 + jitterX, y + jitterY);
                }
            }
            
            drawStar(ctx, x, y, size, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 144 - 90) * Math.PI / 180;
                    const innerAngle = ((i * 144 + 36) - 90) * Math.PI / 180;
                    
                    const outerX = x + Math.cos(angle) * size;
                    const outerY = y + Math.sin(angle) * size;
                    const innerX = x + Math.cos(innerAngle) * size * 0.5;
                    const innerY = y + Math.sin(innerAngle) * size * 0.5;
                    
                    if (i === 0) ctx.moveTo(outerX, outerY);
                    else ctx.lineTo(outerX, outerY);
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fill();
            }
            
            drawHeart(ctx, x, y, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                ctx.moveTo(x, y + 5);
                ctx.bezierCurveTo(x - 10, y - 5, x - 20, y + 5, x - 20, y + 10);
                ctx.bezierCurveTo(x - 20, y + 15, x - 10, y + 25, x, y + 30);
                ctx.bezierCurveTo(x + 10, y + 25, x + 20, y + 15, x + 20, y + 10);
                ctx.bezierCurveTo(x + 20, y + 5, x + 10, y - 5, x, y + 5);
                ctx.stroke();
            }
            
            drawArrow(ctx, x1, y1, x2, y2, color, thickness) {
                // Arrow line
                this.drawOrganicLine(ctx, x1, y1, x2, y2, color, thickness);
                
                // Arrowhead
                const angle = Math.atan2(y2 - y1, x2 - x1);
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI/6), y2 - 10 * Math.sin(angle - Math.PI/6));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI/6), y2 - 10 * Math.sin(angle + Math.PI/6));
                ctx.stroke();
            }
            
            drawSpiral(ctx, x, y, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                
                for (let i = 0; i < 50; i++) {
                    const angle = 0.3 * i;
                    const radius = 2 * i;
                    const px = x + radius * Math.cos(angle);
                    const py = y + radius * Math.sin(angle);
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
            
            drawZigzag(ctx, x1, y1, x2, y2, color, thickness) {
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                
                const segments = 5;
                const segmentWidth = (x2 - x1) / segments;
                
                for (let i = 0; i <= segments; i++) {
                    const x = x1 + i * segmentWidth;
                    const y = i % 2 === 0 ? y1 - 10 : y1 + 10;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            addEraserMarks(ctx) {
                // Create eraser effect by drawing semi-transparent white strokes
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 8 + Math.random() * 4;
                
                const numErases = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numErases; i++) {
                    ctx.beginPath();
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.random() * 40 - 20, y + Math.random() * 40 - 20);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
            }
            
            addSignature(ctx) {
                const signatures = ['~A', 'JK', '-B', 'XO', '   ', ':)', 'ZZ', 'ME'];
                const sig = signatures[Math.floor(Math.random() * signatures.length)];
                
                ctx.fillStyle = this.randomColor();
                ctx.font = '8px monospace';
                ctx.fillText(sig, this.width - 25, this.height - 10);
            }
            
            randomColor() {
                return this.colors[Math.floor(Math.random() * this.colors.length)];
            }
            
            randomPenSize() {
                return this.penSizes[Math.floor(Math.random() * this.penSizes.length)];
            }
        }

        // WebGL CRT Shader System
        class CRTShaderEffect {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = null;
                this.program = null;
                this.uniforms = {};
                this.startTime = Date.now();
                this.mousePos = { x: 0.5, y: 0.5 };
                this.intensity = 0.5;
                this.enabled = devicePerformance.isHighEnd();
                
                if (this.enabled) {
                    this.init();
                }
            }

            init() {
                try {
                    this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                    if (!this.gl) {
                        console.warn('WebGL not supported');
                        this.enabled = false;
                        return;
                    }

                    this.createShaders();
                    this.setupGeometry();
                    this.resize();
                    this.render();

                    // Event listeners
                    window.addEventListener('resize', () => this.resize());
                    window.addEventListener('mousemove', (e) => this.updateMouse(e));
                } catch (error) {
                    console.error('WebGL initialization failed:', error);
                    this.enabled = false;
                }
            }

            createShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                        v_texCoord = a_texCoord;
                    }
                `;

                const fragmentShaderSource = `
                    precision mediump float;
                    
                    varying vec2 v_texCoord;
                    uniform float u_time;
                    uniform vec2 u_resolution;
                    uniform vec2 u_mouse;
                    uniform float u_intensity;
                    
                    // CRT curvature
                    vec2 curve(vec2 uv) {
                        uv = (uv - 0.5) * 2.0;
                        uv *= 1.1;
                        uv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);
                        uv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);
                        uv = (uv / 2.0) + 0.5;
                        uv = uv * 0.92 + 0.04;
                        return uv;
                    }
                    
                    // Scanlines
                    float scanline(vec2 uv) {
                        return sin(uv.y * u_resolution.y * 2.0) * 0.04 * u_intensity;
                    }
                    
                    // Vignette
                    float vignette(vec2 uv) {
                        float dist = distance(uv, vec2(0.5, 0.5));
                        return 1.0 - smoothstep(0.0, 0.7, dist) * 0.5;
                    }
                    
                    // Noise
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        vec2 uv = curve(v_texCoord);
                        
                        // Out of bounds check
                        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                            return;
                        }
                        
                        // Base color (can be replaced with texture sampling)
                        vec3 color = vec3(0.0, 0.4, 0.8) * 0.1;
                        
                        // Add scanlines
                        color += scanline(uv);
                        
                        // Add vignette
                        color *= vignette(uv);
                        
                        // Add chromatic aberration
                        float aberration = 0.002 * u_intensity;
                        color.r += sin(uv.y * 100.0 + u_time) * aberration;
                        color.b -= sin(uv.y * 100.0 + u_time) * aberration;
                        
                        // Add noise
                        color += random(uv + u_time * 0.001) * 0.02 * u_intensity;
                        
                        // Add flicker
                        color *= 1.0 + sin(u_time * 10.0) * 0.01 * u_intensity;
                        
                        // Mouse interaction
                        float mouseDist = distance(uv, u_mouse);
                        color += (1.0 - smoothstep(0.0, 0.3, mouseDist)) * 0.1;
                        
                        gl_FragColor = vec4(color, 0.8);
                    }
                `;

                // Compile shaders
                const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);

                // Create program
                this.program = this.gl.createProgram();
                this.gl.attachShader(this.program, vertexShader);
                this.gl.attachShader(this.program, fragmentShader);
                this.gl.linkProgram(this.program);

                if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                    console.error('Unable to link program');
                    return;
                }

                // Get uniform locations
                this.uniforms = {
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),
                    intensity: this.gl.getUniformLocation(this.program, 'u_intensity')
                };
            }

            compileShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }

            setupGeometry() {
                // Create buffer for quad
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);

                const texCoords = new Float32Array([
                    0, 1,
                    1, 1,
                    0, 0,
                    1, 0
                ]);

                // Position buffer
                const positionBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);

                // Texture coordinate buffer
                const texCoordBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);

                const texCoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');
                this.gl.enableVertexAttribArray(texCoordLocation);
                this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                if (this.gl) {
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            updateMouse(event) {
                this.mousePos.x = event.clientX / window.innerWidth;
                this.mousePos.y = 1.0 - (event.clientY / window.innerHeight);
            }

            setIntensity(value) {
                this.intensity = Math.max(0, Math.min(1, value));
            }

            render() {
                if (!this.enabled || !this.gl) return;

                const time = (Date.now() - this.startTime) * 0.001;

                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);

                this.gl.useProgram(this.program);

                // Update uniforms
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform2f(this.uniforms.mouse, this.mousePos.x, this.mousePos.y);
                this.gl.uniform1f(this.uniforms.intensity, this.intensity);

                // Draw
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(() => this.render());
            }

            toggle(enabled) {
                this.enabled = enabled;
                if (!enabled) {
                    this.gl?.clear(this.gl.COLOR_BUFFER_BIT);
                } else if (!this.gl) {
                    this.init();
                }
            }

            destroy() {
                this.enabled = false;
                if (this.gl) {
                    this.gl.deleteProgram(this.program);
                    this.gl = null;
                }
            }
        }

        // Time-based Content System
        class TimeBasedContent {
            constructor() {
                this.hour = new Date().getHours();
                this.timeOfDay = this.getTimeOfDay();
                this.specialDate = this.checkSpecialDate();
                this.init();
            }

            getTimeOfDay() {
                if (this.hour >= 0 && this.hour < 6) return 'night';
                if (this.hour >= 6 && this.hour < 9) return 'morning';
                if (this.hour >= 9 && this.hour < 18) return 'day';
                if (this.hour >= 18 && this.hour < 21) return 'evening';
                return 'latenight';
            }

            checkSpecialDate() {
                const today = new Date();
                const month = today.getMonth() + 1;
                const day = today.getDate();

                if (month === 12 && day === 25) return 'christmas';
                if (month === 1 && day === 1) return 'newyear';
                if (month === 10 && day === 31) return 'halloween';
                return null;
            }

            getMessages() {
                const messages = {
                    night: [
                        "Still coding? Argo handles calls while you sleep!",
                        "Night owl detected! Join the midnight club!",
                        "Your 3 AM ideas are safe with Argo!"
                    ],
                    morning: [
                        "Good morning! Start your day stress-free!",
                        "Coffee time! Let Argo handle the calls!",
                        "Rise & shine with your AI assistant!"
                    ],
                    day: [
                        "Busy day? Argo's got your back!",
                        "Boost productivity with Argo!",
                        "Work smarter with AI assistance!"
                    ],
                    evening: [
                        "Wind down while Argo works!",
                        "Evening savings await with Argo!",
                        "Relax, Argo handles the rest!"
                    ],
                    latenight: [
                        "Gaming time? Argo's on call duty!",
                        "Netflix & let Argo handle it!",
                        "Perfect time to join the waitlist!"
                    ]
                };

                return messages[this.timeOfDay] || messages.day;
            }

            updateContent() {
                const messageEl = document.getElementById('dynamicMessage');
                const messages = this.getMessages();
                const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                
                if (messageEl) {
                    messageEl.textContent = randomMessage;
                }

                // Update theme based on time
                this.updateTheme();
            }

            updateTheme() {
                const root = document.documentElement;
                const body = document.body;

                if (this.timeOfDay === 'night' || this.timeOfDay === 'latenight') {
                    body.classList.add('night-mode');
                    root.style.setProperty('--time-tint', 'rgba(0, 26, 51, 0.3)');
                    root.style.setProperty('--time-accent', 'var(--argo-gold)');
                } else if (this.timeOfDay === 'morning') {
                    root.style.setProperty('--time-tint', 'rgba(255, 200, 100, 0.1)');
                    root.style.setProperty('--time-accent', '#FFB800');
                } else if (this.timeOfDay === 'evening') {
                    root.style.setProperty('--time-tint', 'rgba(255, 100, 50, 0.1)');
                    root.style.setProperty('--time-accent', '#FF6644');
                }

                // Special date themes
                if (this.specialDate === 'christmas') {
                    this.addSnowEffect();
                } else if (this.specialDate === 'halloween') {
                    root.style.setProperty('--time-accent', '#FF6600');
                }
            }

            addSnowEffect() {
                // Add snow particles for Christmas
                const snowContainer = document.createElement('div');
                snowContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 9997;
                `;

                for (let i = 0; i < 50; i++) {
                    const snowflake = document.createElement('div');
                    snowflake.style.cssText = `
                        position: absolute;
                        width: 4px;
                        height: 4px;
                        background: white;
                        border-radius: 50%;
                        top: ${Math.random() * 100}%;
                        left: ${Math.random() * 100}%;
                        animation: snowfall ${5 + Math.random() * 10}s linear infinite;
                        animation-delay: ${Math.random() * 5}s;
                    `;
                    snowContainer.appendChild(snowflake);
                }

                document.body.appendChild(snowContainer);
            }

            init() {
                this.updateContent();
                // Update every minute
                setInterval(() => this.updateContent(), 60000);
            }
        }

        // Scroll Animation System
        class ScrollAnimationSystem {
            constructor() {
                this.elements = [];
                this.init();
            }

            init() {
                // Setup Intersection Observer
                const observerOptions = {
                    threshold: [0, 0.25, 0.5, 0.75, 1],
                    rootMargin: '0px 0px -10% 0px'
                };

                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('visible');
                            
                            // Special animations based on data attributes
                            if (entry.target.dataset.animation === 'pixelate') {
                                entry.target.classList.add('pixelate-in');
                            } else if (entry.target.dataset.animation === 'glitch') {
                                entry.target.classList.add('glitch-text');
                            }
                        }
                    });
                }, observerOptions);

                // Observe all scroll elements
                document.querySelectorAll('.scroll-element').forEach(el => {
                    this.observer.observe(el);
                });

                // Scroll progress
                this.updateScrollProgress();
                window.addEventListener('scroll', () => this.updateScrollProgress());
            }

            updateScrollProgress() {
                const scrollTop = window.scrollY;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                
                const progressBar = document.getElementById('scrollProgress');
                if (progressBar) {
                    progressBar.style.width = scrollPercent + '%';
                }

                // Update level indicator
                this.updateLevelIndicator(scrollPercent);
            }

            updateLevelIndicator(scrollPercent) {
                const levels = document.querySelectorAll('.level-dot');
                const currentLevel = Math.floor((scrollPercent / 100) * levels.length);
                
                levels.forEach((dot, index) => {
                    if (index <= currentLevel) {
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                    }
                });

                // Update stats - fixed to show out of 6
                const levelStat = document.getElementById('currentLevel');
                if (levelStat) {
                    levelStat.textContent = `${Math.min(currentLevel + 1, 6)}/6`;
                }
            }
        }

        // ============================================
        // COMMUNITY GALLERY SYSTEM - No Backend Version
        // Creates programmatically generated doodles for GitHub Pages
        // ============================================
        class CommunityGallery {
            constructor() {
                this.doodles = [];
                this.page = 1;
                this.isLoading = false;
                this.generator = new DoodleGenerator(200, 150);
                this.init();
            }

            async init() {
                // Generate initial doodles instead of loading from API
                this.generateInitialDoodles();
                // No WebSocket needed for static site
            }

            generateInitialDoodles() {
                // Create 22 diverse doodles on page load
                const doodleTypes = [
                    ...Array(6).fill('robot'),    // 6 robot doodles
                    ...Array(4).fill('phone'),    // 4 phone doodles
                    ...Array(4).fill('ai'),       // 4 AI doodles
                    ...Array(5).fill('text'),     // 5 text doodles
                    ...Array(3).fill('abstract')  // 3 abstract doodles
                ];
                
                // Shuffle for randomness
                doodleTypes.sort(() => Math.random() - 0.5);
                
                // Generate doodles with fake user data
                const userNames = ['Alex', 'Sam', 'Jordan', 'Taylor', 'Morgan', 'Casey', 'Drew', 'Jamie', 'Anonymous'];
                
                const generatedDoodles = doodleTypes.map((type, index) => {
                    return {
                        id: `doodle_${Date.now()}_${index}`,
                        imageData: this.generator.generate(type),
                        userName: Math.random() > 0.3 ? userNames[Math.floor(Math.random() * userNames.length)] : 'Anonymous',
                        waitlistPosition: Math.floor(Math.random() * 25000) + 1,
                        reactions: {
                            heart: Math.floor(Math.random() * 50),
                            love: Math.floor(Math.random() * 30),
                            fire: Math.floor(Math.random() * 40),
                            laugh: Math.floor(Math.random() * 25)
                        },
                        isFeatured: Math.random() > 0.85,
                        createdAt: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString()
                    };
                });
                
                this.renderDoodles(generatedDoodles);
                this.doodles = generatedDoodles;
            }

            async loadDoodles() {
                if (this.isLoading) return;
                this.isLoading = true;

                try {
                    // Generate more random doodles instead of loading from API
                    const moreDoodles = this.generateMoreDoodles();
                    this.renderDoodles(moreDoodles);
                    this.doodles.push(...moreDoodles);
                } catch (error) {
                    console.error('Failed to generate doodles:', error);
                } finally {
                    this.isLoading = false;
                }
            }

            generateMoreDoodles() {
                const types = ['robot', 'phone', 'ai', 'text', 'abstract'];
                const userNames = ['Riley', 'Quinn', 'Avery', 'Sage', 'Anonymous'];
                const newDoodles = [];
                
                for (let i = 0; i < 6; i++) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    newDoodles.push({
                        id: `doodle_${Date.now()}_${i}`,
                        imageData: this.generator.generate(type),
                        userName: userNames[Math.floor(Math.random() * userNames.length)],
                        waitlistPosition: Math.floor(Math.random() * 25000) + 1,
                        reactions: {
                            heart: Math.floor(Math.random() * 20),
                            love: Math.floor(Math.random() * 15),
                            fire: Math.floor(Math.random() * 25),
                            laugh: Math.floor(Math.random() * 10)
                        },
                        isFeatured: false,
                        createdAt: new Date().toISOString()
                    });
                }
                
                return newDoodles;
            }

            renderDoodles(doodles) {
                const gallery = document.getElementById('galleryGrid');
                if (!gallery) return;

                doodles.forEach((doodle, index) => {
                    const card = document.createElement('div');
                    card.className = `doodle-card ${doodle.isFeatured ? 'featured' : ''}`;
                    card.style.animationDelay = `${index * 0.1}s`;
                    
                    card.innerHTML = `
                        <div class="doodle-image">
                            <img src="${doodle.imageData}" alt="Doodle by ${doodle.userName}" style="width: 100%; height: 100%;">
                        </div>
                        <div class="doodle-reactions">
                            <button class="reaction-btn" data-reaction="like" data-id="${doodle.id}">
                                            
                                ${doodle.reactions.like > 0 ? `<span class="reaction-count">${doodle.reactions.like}</span>` : ''}
                            </button>
                            <button class="reaction-btn" data-reaction="love" data-id="${doodle.id}">
                                        
                                ${doodle.reactions.love > 0 ? `<span class="reaction-count">${doodle.reactions.love}</span>` : ''}
                            </button>
                            <button class="reaction-btn" data-reaction="fire" data-id="${doodle.id}">
                                         
                                ${doodle.reactions.fire > 0 ? `<span class="reaction-count">${doodle.reactions.fire}</span>` : ''}
                            </button>
                            <button class="reaction-btn" data-reaction="laugh" data-id="${doodle.id}">
                                         
                                ${doodle.reactions.laugh > 0 ? `<span class="reaction-count">${doodle.reactions.laugh}</span>` : ''}
                            </button>
                        </div>
                    `;

                    // Add reaction listeners
                    card.querySelectorAll('.reaction-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => this.handleReaction(e));
                    });

                    gallery.appendChild(card);
                });

                // Update doodle count
                const doodleCount = document.getElementById('doodleCount');
                if (doodleCount) {
                    const currentCount = parseInt(doodleCount.textContent);
                    doodleCount.textContent = currentCount + doodles.length;
                }
            }

            handleReaction(event) {
                const btn = event.currentTarget;
                const reaction = btn.dataset.reaction;
                const doodleId = btn.dataset.id;

                // Check if user already reacted (using localStorage)
                const reactionKey = `reaction_${doodleId}_${reaction}`;
                if (localStorage.getItem(reactionKey)) {
                    // User already reacted, show feedback
                    btn.style.animation = 'shake 0.3s';
                    setTimeout(() => btn.style.animation = '', 300);
                    return;
                }

                // Animate button
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 500);

                // Update count
                const countEl = btn.querySelector('.reaction-count');
                if (countEl) {
                    const currentCount = parseInt(countEl.textContent);
                    countEl.textContent = currentCount + 1;
                } else {
                    // Find the pixel icon and add count after it
                    const pixelIcon = btn.querySelector('.pixel-icon');
                    if (pixelIcon) {
                        const newCount = document.createElement('span');
                        newCount.className = 'reaction-count';
                        newCount.textContent = '1';
                        pixelIcon.parentNode.appendChild(newCount);
                    } else {
                        btn.innerHTML += '<span class="reaction-count">1</span>';
                    }
                }

                // Store reaction in localStorage
                localStorage.setItem(reactionKey, 'true');
                
                // Simulate live update feel
                this.simulateLiveUpdate();
            }

            simulateLiveUpdate() {
                // Live update simulation - visitor count removed
            }
        }
        
        // ============================================
        // SAVE & SHARE FUNCTIONALITY - No Backend Version
        // Works completely client-side for GitHub Pages
        // ============================================
        
        // Save doodle as image
        function saveDoodleAsImage() {
            const canvas = document.getElementById('enhancedCanvas');
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const filename = `argo-doodle-${timestamp}.png`;
            
            // For mobile, open in new tab
            if (/Mobi|Android/i.test(navigator.userAgent)) {
                const imageData = canvas.toDataURL('image/png');
                const newWindow = window.open();
                newWindow.document.write(`
                    <html>
                        <head>
                            <title>Your Argo Doodle</title>
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <style>
                                body { 
                                    margin: 0; 
                                    background: #000; 
                                    display: flex; 
                                    justify-content: center; 
                                    align-items: center; 
                                    min-height: 100vh;
                                    font-family: monospace;
                                }
                                img { 
                                    max-width: 90%; 
                                    height: auto; 
                                    border: 3px solid #0066CC;
                                    background: white;
                                }
                                .instructions {
                                    position: fixed;
                                    top: 10px;
                                    left: 10px;
                                    right: 10px;
                                    color: #0066CC;
                                    background: rgba(255,255,255,0.9);
                                    padding: 10px;
                                    border-radius: 5px;
                                    text-align: center;
                                    font-size: 14px;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="instructions">Long-press image to save to your device</div>
                            <img src="${imageData}" alt="Your doodle">
                        </body>
                    </html>
                `);
                showSaveSuccessNotification();
            } else {
                // Desktop: direct download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = filename;
                    link.href = url;
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    URL.revokeObjectURL(url);
                    showSaveSuccessNotification();
                    
                    // Also save to localStorage gallery
                    saveToLocalGallery(canvas.toDataURL('image/png'));
                }, 'image/png');
            }
        }
        
        // Show save success notification
        function showSaveSuccessNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification pixel-notification';
            notification.innerHTML = `
                <span class="pixel-icon checkmark"></span>
                DOODLE SAVED!
            `;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #0066CC;
                color: #FFFFFF;
                padding: 12px 20px;
                border: 3px solid #FFFFFF;
                box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
                font-family: 'Press Start 2P', monospace;
                font-size: 10px;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.3s ease;
                z-index: 10000;
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        // Share doodle function
        async function shareDoodle() {
            const canvas = document.getElementById('enhancedCanvas');
            
            // Check if Web Share API is supported
            if (navigator.share) {
                try {
                    // Try to share with image
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    const file = new File([blob], 'my-argo-doodle.png', { type: 'image/png' });
                    
                    // Check if can share files
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            title: 'My Argo Doodle',
                            text: 'Check out my Pictochat-style doodle for Argo!',
                            files: [file]
                        });
                        showShareSuccessNotification();
                    } else {
                        // Fallback: share text only
                        await navigator.share({
                            title: 'Argo - AI Voice Assistant',
                            text: 'I just created a doodle on the Argo landing page! Check it out:',
                            url: window.location.href
                        });
                        showShareSuccessNotification();
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.log('Share failed:', error);
                        fallbackShareOptions();
                    }
                }
            } else {
                // Fallback for browsers without Web Share API
                fallbackShareOptions();
            }
        }
        
        // Fallback share options modal
        function fallbackShareOptions() {
            const modal = document.createElement('div');
            modal.className = 'share-modal pixel-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10001;
            `;
            
            modal.innerHTML = `
                <div class="modal-content" style="
                    background: white;
                    border: 4px solid #0066CC;
                    border-radius: 8px;
                    padding: 20px;
                    max-width: 400px;
                    width: 90%;
                    font-family: 'Press Start 2P', monospace;
                    box-shadow: 0 0 20px rgba(0, 102, 204, 0.5);
                ">
                    <button class="modal-close" onclick="this.closest('.share-modal').remove()" style="
                        float: right;
                        background: #FF4444;
                        color: white;
                        border: none;
                        padding: 5px 10px;
                        font-size: 16px;
                        cursor: pointer;
                        font-family: monospace;
                    ">  </button>
                    
                    <h3 style="color: #0066CC; font-size: 14px; margin: 0 0 15px 0;">SHARE YOUR DOODLE</h3>
                    <p style="font-size: 8px; color: #666; margin-bottom: 20px;">Choose a platform:</p>
                    
                    <div class="share-buttons" style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <button class="share-btn" onclick="shareToTwitter()" style="
                            flex: 1;
                            min-width: 120px;
                            background: #1DA1F2;
                            color: white;
                            border: 3px solid #0066CC;
                            padding: 10px;
                            font-size: 8px;
                            cursor: pointer;
                            font-family: 'Press Start 2P', monospace;
                        ">
                            TWITTER
                        </button>
                        
                        <button class="share-btn" onclick="shareToFacebook()" style="
                            flex: 1;
                            min-width: 120px;
                            background: #4267B2;
                            color: white;
                            border: 3px solid #0066CC;
                            padding: 10px;
                            font-size: 8px;
                            cursor: pointer;
                            font-family: 'Press Start 2P', monospace;
                        ">
                            FACEBOOK
                        </button>
                        
                        <button class="share-btn" onclick="copyShareLink()" style="
                            flex: 1;
                            min-width: 120px;
                            background: #FFB800;
                            color: #0066CC;
                            border: 3px solid #0066CC;
                            padding: 10px;
                            font-size: 8px;
                            cursor: pointer;
                            font-family: 'Press Start 2P', monospace;
                        ">
                            COPY LINK
                        </button>
                        
                        <button class="share-btn" onclick="saveDoodleAsImage(); this.closest('.share-modal').remove()" style="
                            flex: 1;
                            min-width: 120px;
                            background: #0066CC;
                            color: white;
                            border: 3px solid #FFB800;
                            padding: 10px;
                            font-size: 8px;
                            cursor: pointer;
                            font-family: 'Press Start 2P', monospace;
                        ">
                            DOWNLOAD
                        </button>
                    </div>
                    
                    <p style="font-size: 6px; color: #999; margin-top: 15px; text-align: center;">
                        Note: Download your doodle first, then share the image!
                    </p>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }
        
        // Share to Twitter
        function shareToTwitter() {
            const text = encodeURIComponent('I just created a Pictochat-style doodle for Argo AI! Check out their awesome landing page:');
            const url = encodeURIComponent(window.location.href);
            window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
            document.querySelector('.share-modal')?.remove();
        }
        
        // Share to Facebook
        function shareToFacebook() {
            const url = encodeURIComponent(window.location.href);
            window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank');
            document.querySelector('.share-modal')?.remove();
        }
        
        // Copy share link
        function copyShareLink() {
            const text = `Check out my Pictochat doodle on Argo's page! ${window.location.href}`;
            
            navigator.clipboard.writeText(text).then(() => {
                showCopySuccessNotification();
                document.querySelector('.share-modal')?.remove();
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showCopySuccessNotification();
                document.querySelector('.share-modal')?.remove();
            });
        }
        
        // Show share success notification
        function showShareSuccessNotification() {
            const notification = document.createElement('div');
            notification.innerHTML = '<span class="pixel-icon share"></span> SHARED!';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #FFB800;
                color: #0066CC;
                padding: 12px 20px;
                border: 3px solid #0066CC;
                box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
                font-family: 'Press Start 2P', monospace;
                font-size: 10px;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.3s ease;
                z-index: 10000;
            `;
            
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        // Show copy success notification  
        function showCopySuccessNotification() {
            const notification = document.createElement('div');
            notification.innerHTML = '<span class="pixel-icon link"></span> LINK COPIED!';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #44FF44;
                color: #000;
                padding: 12px 20px;
                border: 3px solid #000;
                box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
                font-family: 'Press Start 2P', monospace;
                font-size: 10px;
                opacity: 0;
                transform: translateY(-20px);
                transition: all 0.3s ease;
                z-index: 10000;
            `;
            
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        // Save to local gallery
        function saveToLocalGallery(imageData) {
            // Get existing doodles from localStorage
            let myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            
            // Add new doodle with timestamp
            myDoodles.push({
                id: Date.now(),
                imageData: imageData,
                timestamp: new Date().toISOString()
            });
            
            // Limit to 10 most recent doodles
            if (myDoodles.length > 10) {
                myDoodles = myDoodles.slice(-10);
            }
            
            // Save back to localStorage
            localStorage.setItem('myArgoDoodles', JSON.stringify(myDoodles));
            
            // Display in "My Doodles" section
            displayMyDoodles();
        }
        
        // Display user's saved doodles
        function displayMyDoodles() {
            const myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            const container = document.getElementById('myDoodlesContainer');
            
            if (!container) return;
            
            if (myDoodles.length === 0) {
                container.innerHTML = '<p class="empty-state" style="text-align: center; color: #999; font-size: 10px;">Your doodles will appear here!</p>';
                return;
            }
            
            container.innerHTML = '';
            container.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;';
            
            myDoodles.reverse().forEach(doodle => {
                const item = document.createElement('div');
                item.className = 'my-doodle-item';
                item.style.cssText = 'background: white; border: 3px solid #0066CC; border-radius: 8px; padding: 10px; position: relative;';
                item.innerHTML = `
                    <img src="${doodle.imageData}" alt="My doodle" style="width: 100%; height: auto; display: block;">
                    <div class="doodle-actions" style="display: flex; gap: 10px; margin-top: 10px;">
                        <button onclick="downloadDoodle('${doodle.id}')" title="Download" style="
                            flex: 1;
                            background: #0066CC;
                            color: white;
                            border: none;
                            padding: 5px;
                            cursor: pointer;
                            font-size: 8px;
                            font-family: 'Press Start 2P', monospace;
                        ">
                            SAVE
                        </button>
                        <button onclick="deleteDoodle('${doodle.id}')" title="Delete" style="
                            flex: 1;
                            background: #FF4444;
                            color: white;
                            border: none;
                            padding: 5px;
                            cursor: pointer;
                            font-size: 8px;
                            font-family: 'Press Start 2P', monospace;
                        ">
                            DELETE
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });
        }
        
        // Download doodle from gallery
        function downloadDoodle(id) {
            const myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            const doodle = myDoodles.find(d => d.id == id);
            
            if (doodle) {
                const link = document.createElement('a');
                link.download = `my-doodle-${id}.png`;
                link.href = doodle.imageData;
                link.click();
                showSaveSuccessNotification();
            }
        }
        
        // Delete doodle from gallery
        function deleteDoodle(id) {
            let myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            myDoodles = myDoodles.filter(d => d.id != id);
            localStorage.setItem('myArgoDoodles', JSON.stringify(myDoodles));
            displayMyDoodles();
        }
        
        // Fallback share modal
        function fallbackShareOptions() {
            const modal = document.createElement('div');
            modal.className = 'share-modal pixel-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <button class="modal-close" onclick="this.closest('.share-modal').remove()">  </button>
                    <h3>SHARE YOUR DOODLE</h3>
                    <p class="modal-subtitle">Choose a platform:</p>
                    
                    <div class="share-buttons">
                        <button class="share-btn twitter-btn" onclick="shareToTwitter()">
                            <span class="pixel-icon twitter"></span>
                            TWITTER
                        </button>
                        
                        <button class="share-btn facebook-btn" onclick="shareToFacebook()">
                            <span class="pixel-icon facebook"></span>
                            FACEBOOK
                        </button>
                        
                        <button class="share-btn copy-btn" onclick="copyShareLink()">
                            <span class="pixel-icon link"></span>
                            COPY LINK
                        </button>
                        
                        <button class="share-btn download-btn" onclick="saveDoodleAsImage()">
                            <span class="pixel-icon download"></span>
                            DOWNLOAD
                        </button>
                    </div>
                    
                    <p class="modal-note">
                        Note: Download your doodle, then share the image on your platform of choice!
                    </p>
                </div>
            `;
            
            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('show'), 10);
            
            // Generate pixel icons for share buttons
            const pixelIcons = modal.querySelectorAll('.pixel-icon');
            pixelIcons.forEach(icon => {
                const type = icon.className.split(' ')[1];
                const imgData = PixelIconGenerator.createIcon(type);
                const img = document.createElement('img');
                img.src = imgData;
                img.className = icon.className;
                icon.parentNode.replaceChild(img, icon);
            });
        }
        
        window.shareToTwitter = function() {
            const text = encodeURIComponent('I just created a Pictochat-style doodle for Argo AI! Check out their awesome landing page:');
            const url = encodeURIComponent(window.location.href);
            window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
            document.querySelector('.share-modal')?.remove();
        };
        
        window.shareToFacebook = function() {
            const url = encodeURIComponent(window.location.href);
            window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank');
            document.querySelector('.share-modal')?.remove();
        };
        
        window.copyShareLink = function() {
            const text = `Check out my Pictochat doodle on Argo's page! ${window.location.href}`;
            
            navigator.clipboard.writeText(text).then(() => {
                showCopySuccessNotification();
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showCopySuccessNotification();
            });
            document.querySelector('.share-modal')?.remove();
        };
        
        // Save to local gallery
        function saveToLocalGallery() {
            const canvas = document.getElementById('enhancedCanvas');
            const imageData = canvas.toDataURL('image/png');
            
            let myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            
            myDoodles.push({
                id: Date.now(),
                imageData: imageData,
                timestamp: new Date().toISOString()
            });
            
            if (myDoodles.length > 10) {
                myDoodles = myDoodles.slice(-10);
            }
            
            localStorage.setItem('myArgoDoodles', JSON.stringify(myDoodles));
            
            displayMyDoodles();
            showSaveSuccessNotification();
        }
        
        // Display user's saved doodles
        function displayMyDoodles() {
            const myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            const container = document.getElementById('myDoodlesContainer');
            
            if (!container) return;
            
            if (myDoodles.length === 0) {
                container.innerHTML = '<p class="empty-state">Your doodles will appear here!</p>';
                return;
            }
            
            container.innerHTML = '';
            myDoodles.reverse().forEach(doodle => {
                const item = document.createElement('div');
                item.className = 'my-doodle-item';
                item.innerHTML = `
                    <img src="${doodle.imageData}" alt="My doodle">
                    <div class="doodle-actions">
                        <button onclick="downloadDoodle('${doodle.id}')" title="Download">
                            <img src="${PixelIconGenerator.createIcon('download')}" class="pixel-icon small" alt="Download">
                        </button>
                        <button onclick="deleteDoodle('${doodle.id}')" title="Delete">
                            <img src="${PixelIconGenerator.createIcon('trash')}" class="pixel-icon small" alt="Delete">
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });
        }
        
        // Download a saved doodle
        window.downloadDoodle = function(id) {
            const myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            const doodle = myDoodles.find(d => d.id == id);
            
            if (doodle) {
                const link = document.createElement('a');
                link.download = `argo-doodle-${id}.png`;
                link.href = doodle.imageData;
                link.click();
            }
        };
        
        // Delete a saved doodle
        window.deleteDoodle = function(id) {
            let myDoodles = JSON.parse(localStorage.getItem('myArgoDoodles') || '[]');
            myDoodles = myDoodles.filter(d => d.id != id);
            localStorage.setItem('myArgoDoodles', JSON.stringify(myDoodles));
            displayMyDoodles();
        };
        
        // Show success notifications
        function showSaveSuccessNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification pixel-notification';
            const checkIcon = PixelIconGenerator.createIcon('check', 16, '#FFFFFF');
            notification.innerHTML = `
                <img src="${checkIcon}" class="pixel-icon" alt="Check">
                DOODLE SAVED!
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        function showShareSuccessNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification pixel-notification';
            const checkIcon = PixelIconGenerator.createIcon('check', 16, '#FFFFFF');
            notification.innerHTML = `
                <img src="${checkIcon}" class="pixel-icon" alt="Check">
                SHARED SUCCESSFULLY!
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        function showCopySuccessNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification pixel-notification';
            const checkIcon = PixelIconGenerator.createIcon('check', 16, '#FFFFFF');
            notification.innerHTML = `
                <img src="${checkIcon}" class="pixel-icon" alt="Check">
                LINK COPIED!
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        // ============================================
        // GALLERY INITIALIZATION WITH FAKE DOODLES
        // Added: Phase 3 Enhancement
        // ============================================
        
        function initializeGalleryWithFakeDoodles() {
            const gallery = document.getElementById('galleryGrid');
            if (!gallery) return;
            
            // Clear existing placeholder content
            gallery.innerHTML = '';
            
            const generator = new DoodleGenerator(200, 150);
            
            // Define distribution of doodle types for variety
            const types = [
                ...Array(6).fill('robot'),    // 6 robot doodles
                ...Array(4).fill('phone'),    // 4 phone doodles
                ...Array(4).fill('ai'),       // 4 AI doodles
                ...Array(5).fill('text'),     // 5 text doodles
                ...Array(3).fill('abstract')  // 3 abstract doodles
            ];
            
            // Shuffle for randomness
            types.sort(() => Math.random() - 0.5);
            
            // Generate new doodles
            types.forEach((type, index) => {
                setTimeout(() => {
                    const imageData = generator.generate(type);
                    
                    const doodleItem = document.createElement('div');
                    doodleItem.className = 'doodle-card';
                    doodleItem.style.animationDelay = `${index * 0.05}s`;
                    
                    // Random reaction counts for realism
                    const likes = Math.floor(Math.random() * 50);
                    const loves = Math.floor(Math.random() * 30);
                    const fires = Math.floor(Math.random() * 25);
                    const laughs = Math.floor(Math.random() * 20);
                    
                    // Create pixel icons for reactions
                    const heartIcon = PixelIconGenerator.createIcon('heart', 12, '#FF0066');
                    const fireIcon = PixelIconGenerator.createIcon('fire', 12, '#FF6600');
                    const laughIcon = PixelIconGenerator.createIcon('laugh', 12, '#FFCC00');
                    const thumbsUpIcon = PixelIconGenerator.createIcon('thumbsUp', 12, '#0066CC');
                    
                    doodleItem.innerHTML = `
                        <div class="doodle-image">
                            <img src="${imageData}" alt="Community doodle ${index + 1}" 
                                 style="width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated;">
                        </div>
                        <div class="doodle-reactions">
                            <button class="reaction-btn" data-reaction="like" data-count="${likes}">
                                <img src="${heartIcon}" class="pixel-icon small" alt="Like">
                                ${likes > 0 ? `<span class="reaction-count">${likes}</span>` : ''}
                            </button>
                            <button class="reaction-btn" data-reaction="love" data-count="${loves}">
                                <img src="${thumbsUpIcon}" class="pixel-icon small" alt="Love">
                                ${loves > 0 ? `<span class="reaction-count">${loves}</span>` : ''}
                            </button>
                            <button class="reaction-btn" data-reaction="fire" data-count="${fires}">
                                <img src="${fireIcon}" class="pixel-icon small" alt="Fire">
                                ${fires > 0 ? `<span class="reaction-count">${fires}</span>` : ''}
                            </button>
                            <button class="reaction-btn" data-reaction="laugh" data-count="${laughs}">
                                <img src="${laughIcon}" class="pixel-icon small" alt="Laugh">
                                ${laughs > 0 ? `<span class="reaction-count">${laughs}</span>` : ''}
                            </button>
                        </div>
                    `;
                    
                    // Add reaction click handlers
                    doodleItem.querySelectorAll('.reaction-btn').forEach(btn => {
                        btn.addEventListener('click', function(e) {
                            e.stopPropagation();
                            const currentCount = parseInt(this.dataset.count) || 0;
                            const newCount = currentCount + 1;
                            this.dataset.count = newCount;
                            
                            // Update or add count display
                            let countEl = this.querySelector('.reaction-count');
                            if (!countEl) {
                                countEl = document.createElement('span');
                                countEl.className = 'reaction-count';
                                this.appendChild(countEl);
                            }
                            countEl.textContent = newCount;
                            
                            // Add animation
                            this.classList.add('active');
                            setTimeout(() => this.classList.remove('active'), 500);
                        });
                    });
                    
                    gallery.appendChild(doodleItem);
                }, index * 100); // Stagger the generation for visual effect
            });
        }

        // Enhanced Drawing Canvas
        class EnhancedCanvas {
            constructor() {
                this.canvas = document.getElementById('enhancedCanvas');
                if (!this.canvas) return;
                
                this.ctx = this.canvas.getContext('2d');
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.brushSize = 3;
                this.isEraser = false;
                this.history = [];
                this.historyIndex = -1;
                
                this.init();
            }

            init() {
                // Set canvas size
                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Clear canvas with white background
                this.clear();

                // Drawing events
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseleave', () => this.stopDrawing());

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.handleTouch(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouch(e));
                this.canvas.addEventListener('touchend', () => this.stopDrawing());

                // Color palette
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', () => {
                        document.querySelector('.color-swatch.active')?.classList.remove('active');
                        swatch.classList.add('active');
                        this.currentColor = swatch.dataset.color;
                        this.isEraser = false;
                    });
                });

                // Brush size
                document.querySelectorAll('.brush-size-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelector('.brush-size-btn.active')?.classList.remove('active');
                        btn.classList.add('active');
                        this.brushSize = parseInt(btn.dataset.size);
                    });
                });

                // Tools
                document.getElementById('clearBtn')?.addEventListener('click', () => this.clear());
                document.getElementById('eraserBtn')?.addEventListener('click', () => this.toggleEraser());
                document.getElementById('saveBtn')?.addEventListener('click', () => this.save());
                document.getElementById('shareBtn')?.addEventListener('click', () => this.share());

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') {
                            e.preventDefault();
                            this.undo();
                        } else if (e.key === 'y') {
                            e.preventDefault();
                            this.redo();
                        }
                    }
                });
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            startDrawing(e) {
                this.isDrawing = true;
                this.saveState();
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
            }

            draw(e) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.ctx.lineWidth = this.brushSize;
                this.ctx.lineCap = 'square';
                this.ctx.lineJoin = 'miter';
                
                if (this.isEraser) {
                    this.ctx.globalCompositeOperation = 'destination-out';
                } else {
                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.strokeStyle = this.currentColor;
                }
                
                this.ctx.lineTo(x, y);
                this.ctx.stroke();
            }

            stopDrawing() {
                this.isDrawing = false;
            }

            handleTouch(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent(
                    e.type === 'touchstart' ? 'mousedown' : 
                    e.type === 'touchmove' ? 'mousemove' : 'mouseup', 
                    {
                        clientX: touch?.clientX || 0,
                        clientY: touch?.clientY || 0
                    }
                );
                this.canvas.dispatchEvent(mouseEvent);
            }

            clear() {
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.saveState();
            }

            toggleEraser() {
                this.isEraser = !this.isEraser;
                const eraserBtn = document.getElementById('eraserBtn');
                if (eraserBtn) {
                    eraserBtn.style.background = this.isEraser ? 'var(--argo-blue)' : 'var(--argo-white)';
                    eraserBtn.style.color = this.isEraser ? 'var(--argo-white)' : 'var(--argo-dark-blue)';
                }
            }

            saveState() {
                this.historyIndex++;
                if (this.historyIndex < this.history.length) {
                    this.history.length = this.historyIndex;
                }
                this.history.push(this.canvas.toDataURL());
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState();
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState();
                }
            }

            restoreState() {
                const img = new Image();
                img.src = this.history[this.historyIndex];
                img.onload = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(img, 0, 0);
                };
            }

            save() {
                // Call the enhanced save function
                saveDoodleAsImage();
                
                // Also save to local gallery
                saveToLocalGallery();
            }

            async share() {
                // Call the enhanced share function
                shareDoodle();
            }

            createDoodleCard(doodle) {
                const card = document.createElement('div');
                card.className = 'doodle-card';
                card.innerHTML = `
                    <div class="doodle-image">
                        <img src="${doodle.imageData}" alt="Your doodle" style="width: 100%; height: 100%;">
                    </div>
                    <div class="doodle-reactions">
                        <button class="reaction-btn">            </button>
                        <button class="reaction-btn">        </button>
                        <button class="reaction-btn">         </button>
                        <button class="reaction-btn">         </button>
                    </div>
                `;
                return card;
            }

            showAchievement(title, desc) {
                const badge = document.getElementById('achievementBadge');
                const titleEl = badge.querySelector('.achievement-title');
                const descEl = document.getElementById('achievementDesc');
                
                titleEl.textContent = title;
                descEl.textContent = desc;
                
                badge.style.display = 'block';
                setTimeout(() => {
                    badge.style.display = 'none';
                }, 3000);
            }
        }

        // Statistics Tracker
        class StatsTracker {
            constructor() {
                this.startTime = Date.now();
                this.init();
            }

            init() {
                this.updateStats();
                setInterval(() => this.updateStats(), 1000);
            }

            updateStats() {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                
                const timeSpent = document.getElementById('timeSpent');
                if (timeSpent) {
                    timeSpent.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }
        }



        // Load More Doodles
        window.loadMoreDoodles = function() {
            if (window.gallery) {
                window.gallery.loadDoodles();
            }
        };

        // Initialize everything
        window.addEventListener('DOMContentLoaded', () => {
            // ============================================
            // PICTOCHAT DRAWING TOOLS CONTROLLER
            // Phase 5 Enhancement - Complete Implementation
            // ============================================
            
            class PictochatDrawingController {
                constructor(canvasId) {
                    this.canvas = document.getElementById(canvasId);
                    if (!this.canvas) return;
                    
                    this.ctx = this.canvas.getContext('2d');
                    this.isDrawing = false;
                    this.currentColor = '#000000';
                    this.currentSize = 'small';
                    this.currentTool = 'pen';
                    this.lastX = 0;
                    this.lastY = 0;
                    
                    // Brush size mapping for Pictochat style
                    this.brushSizes = {
                        small: 3,
                        medium: 6,
                        large: 10
                    };
                    
                    this.setupCanvas();
                    this.initializeEventListeners();
                }
                
                setupCanvas() {
                    // Set canvas dimensions properly
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    
                    // Clear with semi-transparent white to show notebook lines
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Set pixel-perfect rendering
                    this.ctx.imageSmoothingEnabled = false;
                    this.ctx.lineCap = 'square';
                    this.ctx.lineJoin = 'miter';
                }
                
                initializeEventListeners() {
                    // Color selection
                    document.querySelectorAll('.color-swatch').forEach(swatch => {
                        swatch.addEventListener('click', (e) => {
                            this.selectColor(e.currentTarget);
                        });
                    });
                    
                    // Brush size selection
                    document.querySelectorAll('.size-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            this.selectBrushSize(e.currentTarget);
                        });
                    });
                    
                    // Tool buttons
                    document.querySelectorAll('[data-tool]').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const tool = e.currentTarget.dataset.tool;
                            this.selectTool(tool);
                        });
                    });
                    
                    // Canvas drawing events
                    this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                    this.canvas.addEventListener('mousemove', this.draw.bind(this));
                    this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                    this.canvas.addEventListener('mouseleave', this.stopDrawing.bind(this));
                    
                    // Touch support for mobile
                    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                    this.canvas.addEventListener('touchend', this.stopDrawing.bind(this));
                }
                
                selectColor(element) {
                    this.currentColor = element.dataset.color;
                    this.currentTool = 'pen'; // Auto-switch back to pen
                    
                    // Update UI
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    element.classList.add('active');
                    
                    // Reset tool buttons
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active-tool'));
                    document.getElementById('penBtn')?.classList.add('active-tool');
                }
                
                selectBrushSize(element) {
                    this.currentSize = element.dataset.size;
                    
                    // Update UI
                    document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                    element.classList.add('active');
                }
                
                selectTool(tool) {
                    this.currentTool = tool;
                    
                    if (tool === 'clear') {
                        this.clearCanvas();
                    } else if (tool === 'pen' || tool === 'eraser') {
                        // Update active tool indicator
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active-tool'));
                        document.querySelector(`[data-tool="${tool}"]`)?.classList.add('active-tool');
                    }
                }
                
                clearCanvas() {
                    if (confirm('Clear your doodle? This cannot be undone!')) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                }
                
                startDrawing(e) {
                    this.isDrawing = true;
                    const rect = this.canvas.getBoundingClientRect();
                    this.lastX = e.clientX - rect.left;
                    this.lastY = e.clientY - rect.top;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.lastX, this.lastY);
                }
                
                draw(e) {
                    if (!this.isDrawing) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Pixelate coordinates for authentic DS feel
                    const pixelX = Math.floor(x / 2) * 2;
                    const pixelY = Math.floor(y / 2) * 2;
                    
                    this.ctx.lineWidth = this.brushSizes[this.currentSize];
                    
                    if (this.currentTool === 'eraser') {
                        this.ctx.globalCompositeOperation = 'destination-out';
                    } else {
                        this.ctx.globalCompositeOperation = 'source-over';
                        this.ctx.strokeStyle = this.currentColor;
                    }
                    
                    this.ctx.lineTo(pixelX, pixelY);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(pixelX, pixelY);
                    
                    this.lastX = pixelX;
                    this.lastY = pixelY;
                }
                
                stopDrawing() {
                    this.isDrawing = false;
                    this.ctx.beginPath();
                }
                
                handleTouchStart(e) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                }
                
                handleTouchMove(e) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                }
                
                isCanvasEmpty() {
                    const pixelData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height).data;
                    for (let i = 0; i < pixelData.length; i += 4) {
                        // Check if any pixel is not white
                        if (pixelData[i] !== 255 || pixelData[i+1] !== 255 || pixelData[i+2] !== 255) {
                            return false;
                        }
                    }
                    return true;
                }
                
                getCanvasData() {
                    return this.canvas.toDataURL('image/png');
                }
            }
            
            // ============================================
            // MESSAGE SEND ANIMATION SYSTEM
            // Authentic Pictochat flying message animation
            // ============================================
            
            class MessageSendAnimation {
                constructor() {
                    this.canvas = document.getElementById('enhancedCanvas');
                    this.messageArea = document.getElementById('messageDisplayArea');
                    this.isAnimating = false;
                }
                
                async sendMessage() {
                    if (this.isAnimating) {
                        console.warn('Animation already in progress');
                        return;
                    }
                    
                    // Check if canvas has content
                    if (window.pictochatDrawing && window.pictochatDrawing.isCanvasEmpty()) {
                        alert('Draw something first!');
                        return;
                    }
                    
                    this.isAnimating = true;
                    
                    try {
                        // Get canvas image data
                        const imageData = window.pictochatDrawing.getCanvasData();
                        
                        // Create flying element
                        const flyingElement = this.createFlyingElement(imageData);
                        document.body.appendChild(flyingElement);
                        
                        // Perform animation
                        await this.animateFlight(flyingElement);
                        
                        // Add to message area
                        this.addToMessageArea(imageData);
                        
                        // Cleanup
                        flyingElement.remove();
                        
                        // Clear canvas for next doodle
                        if (window.pictochatDrawing) {
                            const ctx = window.pictochatDrawing.ctx;
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.fillRect(0, 0, window.pictochatDrawing.canvas.width, window.pictochatDrawing.canvas.height);
                        }
                        
                    } catch (error) {
                        console.error('Send animation failed:', error);
                    } finally {
                        this.isAnimating = false;
                    }
                }
                
                createFlyingElement(imageData) {
                    const element = document.createElement('div');
                    element.className = 'flying-message';
                    element.style.cssText = `
                        position: fixed;
                        z-index: 9999;
                        pointer-events: none;
                        image-rendering: pixelated;
                        width: 200px;
                    `;
                    
                    const img = document.createElement('img');
                    img.src = imageData;
                    img.style.cssText = `
                        display: block;
                        width: 100%;
                        height: auto;
                        image-rendering: pixelated;
                    `;
                    
                    element.appendChild(img);
                    
                    // Position at canvas location
                    const canvasRect = this.canvas.getBoundingClientRect();
                    element.style.left = canvasRect.left + canvasRect.width / 2 - 100 + 'px';
                    element.style.top = canvasRect.top + 'px';
                    
                    return element;
                }
                
                async animateFlight(element) {
                    const startRect = element.getBoundingClientRect();
                    const messageArea = this.messageArea || document.querySelector('.message-display-area');
                    
                    if (!messageArea) {
                        console.error('Message area not found');
                        return;
                    }
                    
                    const endRect = messageArea.getBoundingClientRect();
                    
                    // Calculate target position
                    const targetX = endRect.left + (endRect.width / 2) - 100;
                    const targetY = endRect.top + 20;
                    
                    // Create animation keyframes for authentic DS feel
                    const keyframes = [
                        {
                            // Start
                            left: startRect.left + 'px',
                            top: startRect.top + 'px',
                            transform: 'scale(1) rotate(0deg)',
                            opacity: 1,
                            filter: 'brightness(1)'
                        },
                        {
                            // Lift off
                            offset: 0.15,
                            left: startRect.left + 'px',
                            top: (startRect.top - 30) + 'px',
                            transform: 'scale(0.95) rotate(-10deg)',
                            opacity: 1
                        },
                        {
                            // Mid-flight
                            offset: 0.5,
                            left: ((startRect.left + targetX) / 2) + 'px',
                            top: (Math.min(startRect.top, targetY) - 100) + 'px',
                            transform: 'scale(0.6) rotate(180deg)',
                            opacity: 0.9
                        },
                        {
                            // Approaching
                            offset: 0.85,
                            left: targetX + 'px',
                            top: (targetY - 20) + 'px',
                            transform: 'scale(0.7) rotate(340deg)',
                            opacity: 1
                        },
                        {
                            // Arrival
                            left: targetX + 'px',
                            top: targetY + 'px',
                            transform: 'scale(0.8) rotate(360deg)',
                            opacity: 1,
                            filter: 'brightness(1.3)'
                        }
                    ];
                    
                    // Animation options
                    const options = {
                        duration: 800,
                        easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                        fill: 'forwards'
                    };
                    
                    // Start animation
                    const animation = element.animate(keyframes, options);
                    
                    // Add trailing particles
                    this.addTrailEffect(startRect, { left: targetX, top: targetY });
                    
                    // Wait for animation to complete
                    await animation.finished;
                    
                    // Bounce effect on arrival
                    await element.animate([
                        { transform: 'scale(0.8) rotate(360deg)' },
                        { transform: 'scale(0.9) rotate(360deg)' },
                        { transform: 'scale(0.8) rotate(360deg)' }
                    ], {
                        duration: 200,
                        easing: 'ease-in-out'
                    }).finished;
                }
                
                addTrailEffect(startPos, endPos) {
                    const particleCount = 5;
                    for (let i = 0; i < particleCount; i++) {
                        setTimeout(() => {
                            const particle = document.createElement('div');
                            particle.className = 'trail-particle';
                            particle.style.left = startPos.left + startPos.width / 2 + 'px';
                            particle.style.top = startPos.top + startPos.height / 2 + 'px';
                            document.body.appendChild(particle);
                            
                            // Animate particle
                            particle.animate([
                                {
                                    left: particle.style.left,
                                    top: particle.style.top,
                                    opacity: 1,
                                    transform: 'scale(1)'
                                },
                                {
                                    left: endPos.left + Math.random() * 50 - 25 + 'px',
                                    top: endPos.top + Math.random() * 50 - 25 + 'px',
                                    opacity: 0,
                                    transform: 'scale(0.5)'
                                }
                            ], {
                                duration: 600,
                                easing: 'ease-out'
                            });
                            
                            // Remove particle after animation
                            setTimeout(() => particle.remove(), 600);
                        }, i * 100);
                    }
                }
                
                addToMessageArea(imageData) {
                    if (!this.messageArea) {
                        this.messageArea = document.getElementById('messageDisplayArea');
                        if (!this.messageArea) {
                            // Create message area if it doesn't exist
                            this.messageArea = document.createElement('div');
                            this.messageArea.id = 'messageDisplayArea';
                            this.messageArea.className = 'message-display-area';
                            const canvasContainer = document.querySelector('.canvas-container');
                            if (canvasContainer) {
                                canvasContainer.appendChild(this.messageArea);
                            }
                        }
                    }
                    
                    // Create message bubble
                    const messageBubble = document.createElement('div');
                    messageBubble.className = 'message-bubble new-message';
                    messageBubble.innerHTML = `
                        <div class="message-header">
                            <span class="sender">YOU</span>
                            <span class="timestamp">${this.getCurrentTime()}</span>
                        </div>
                        <div class="message-content doodle-message">
                            <img src="${imageData}" alt="Your doodle" class="doodle-image">
                        </div>
                    `;
                    
                    // Add to message area
                    this.messageArea.appendChild(messageBubble);
                    
                    // Entrance animation
                    setTimeout(() => {
                        messageBubble.classList.add('visible');
                    }, 10);
                    
                    // Scroll to new message
                    this.messageArea.scrollTop = this.messageArea.scrollHeight;
                }
                
                getCurrentTime() {
                    const now = new Date();
                    return now.toLocaleTimeString('en-US', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                }
            }
            
            // ============================================
            // DS BOOT SEQUENCE CONTROLLER
            // Nintendo DS-style startup animation
            // ============================================
            
            class DSBootSequence {
                constructor() {
                    this.hasSeenBoot = localStorage.getItem('argoBootSeen') === 'true';
                    this.isSkipped = false;
                }
                
                async start() {
                    // Skip if user has seen it before
                    if (this.hasSeenBoot) {
                        console.log('Boot sequence already seen, skipping');
                        return;
                    }
                    
                    // Create boot screen
                    const bootScreen = this.createBootScreen();
                    document.body.appendChild(bootScreen);
                    
                    // Add event listeners
                    this.addEventListeners(bootScreen);
                    
                    // Run sequence
                    await this.runSequence(bootScreen);
                    
                    // Mark as seen
                    localStorage.setItem('argoBootSeen', 'true');
                }
                
                createBootScreen() {
                    const bootScreen = document.createElement('div');
                    bootScreen.id = 'dsBootScreen';
                    bootScreen.className = 'ds-boot-screen';
                    bootScreen.innerHTML = `
                        <!-- Stage 1 & 2: Warning -->
                        <div class="boot-stage" data-stage="warning">
                            <div class="warning-text">
                                <p class="warning-title">HEALTH AND SAFETY</p>
                                <p class="warning-body">
                                    BEFORE USING THIS WEBSITE, READ THE<br>
                                    OPERATIONS MANUAL FOR IMPORTANT<br>
                                    INFORMATION ABOUT YOUR HEALTH AND SAFETY.
                                </p>
                            </div>
                        </div>
                        
                        <!-- Stage 3: Logo -->
                        <div class="boot-stage" data-stage="logo" style="display: none;">
                            <div class="boot-logo">
                                <p class="logo-text">ARGO SYSTEM</p>
                                <p class="logo-subtitle">PICTOCHAT EDITION</p>
                            </div>
                        </div>
                        
                        <!-- Stage 4: Loading -->
                        <div class="boot-stage" data-stage="loading" style="display: none;">
                            <div class="boot-loading">
                                <div class="loading-bar-container">
                                    <div class="loading-bar"></div>
                                </div>
                                <p class="loading-text">LOADING ARGO...</p>
                            </div>
                        </div>
                        
                        <!-- Skip button -->
                        <button class="boot-skip-btn">
                            PRESS SPACE TO SKIP
                        </button>
                    `;
                    return bootScreen;
                }
                
                addEventListeners(bootScreen) {
                    const skipBtn = bootScreen.querySelector('.boot-skip-btn');
                    
                    // Skip button click
                    skipBtn.addEventListener('click', () => this.skip(bootScreen));
                    
                    // Space key to skip
                    const keyHandler = (e) => {
                        if (e.code === 'Space' && !this.isSkipped) {
                            this.skip(bootScreen);
                            document.removeEventListener('keydown', keyHandler);
                        }
                    };
                    document.addEventListener('keydown', keyHandler);
                    
                    // Click anywhere to skip
                    bootScreen.addEventListener('click', (e) => {
                        if (e.target === bootScreen) {
                            this.skip(bootScreen);
                        }
                    });
                }
                
                async runSequence(bootScreen) {
                    // Stage 1: Warning (1.5 seconds)
                    await this.showStage(bootScreen, 'warning', 1500);
                    if (this.isSkipped) return;
                    
                    // Stage 2: Logo (1.2 seconds)
                    await this.showStage(bootScreen, 'logo', 1200);
                    if (this.isSkipped) return;
                    
                    // Stage 3: Loading (1.5 seconds)
                    await this.showStage(bootScreen, 'loading', 1500);
                    if (this.isSkipped) return;
                    
                    // Complete sequence
                    await this.complete(bootScreen);
                }
                
                async showStage(bootScreen, stageName, duration) {
                    return new Promise((resolve) => {
                        // Hide all stages
                        bootScreen.querySelectorAll('.boot-stage').forEach(stage => {
                            stage.style.display = 'none';
                        });
                        
                        // Show current stage
                        const stageElement = bootScreen.querySelector(`[data-stage="${stageName}"]`);
                        if (stageElement) {
                            stageElement.style.display = 'block';
                        }
                        
                        // Wait for duration
                        setTimeout(resolve, duration);
                    });
                }
                
                skip(bootScreen) {
                    this.isSkipped = true;
                    this.complete(bootScreen);
                }
                
                async complete(bootScreen) {
                    // Fade out boot screen
                    bootScreen.classList.add('fade-out');
                    
                    // Wait for fade animation
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    // Remove from DOM
                    bootScreen.remove();
                    
                    // Show main content
                    document.body.classList.add('boot-complete');
                }
                
                // Reset boot sequence (for testing)
                static reset() {
                    localStorage.removeItem('argoBootSeen');
                    console.log('Boot sequence reset. Reload page to see it again.');
                }
            }
            
            // ============================================
            // INITIALIZE ALL PHASE 5 FEATURES
            // ============================================
            
            // Initialize Pictochat drawing controller
            window.pictochatDrawing = new PictochatDrawingController('enhancedCanvas');
            
            // Initialize message sender
            window.messageSender = new MessageSendAnimation();
            
            // Initialize DS boot sequence
            const bootSequence = new DSBootSequence();
            bootSequence.start();
            
            // Expose functions for buttons
            window.sendDoodleMessage = () => {
                if (window.messageSender) {
                    window.messageSender.sendMessage();
                }
            };
            
            // Expose boot reset for testing
            window.resetBootSequence = () => DSBootSequence.reset();
            // Initialize WebGL effects
            const webglCanvas = document.getElementById('webglCanvas');
            if (webglCanvas) {
                window.crtEffect = new CRTShaderEffect(webglCanvas);
            }

            // Initialize time-based content
            new TimeBasedContent();

            // Initialize scroll animations
            new ScrollAnimationSystem();

            // Initialize community gallery
            window.gallery = new CommunityGallery();

            // Initialize enhanced canvas
            new EnhancedCanvas();

            // Initialize stats tracker
            new StatsTracker();
            
            // Initialize My Doodles section
            displayMyDoodles();

            // Level navigation
            document.querySelectorAll('.level-dot').forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    const sections = document.querySelectorAll('.section');
                    if (sections[index]) {
                        sections[index].scrollIntoView({ behavior: 'smooth' });
                    }
                });
            });

            // Add CSS for snow animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes snowfall {
                    from {
                        transform: translateY(-100vh);
                    }
                    to {
                        transform: translateY(100vh);
                    }
                }
            `;
            document.head.appendChild(style);

            console.log('%c     ARGO PHASE 3 INITIALIZED', 
                'background: linear-gradient(90deg, #0066CC, #FFB800); color: white; font-size: 24px; font-weight: bold; padding: 10px;');
            console.log('%c    Award-winning experience loaded!', 'color: #FFB800; font-size: 14px;');
            console.log('%c     Community gallery with programmatic doodles ready!', 'color: #00CC00; font-size: 12px;');
            console.log('%c     Save & Share functionality active!', 'color: #FF66CC; font-size: 12px;');
        });
    </script>
</body>
</html>